#process
## Czym są procesy i wątki?
#process #thread
- **Proces** - aktualnie wykonywany przez procesor ciąg poleceń; ten ciąg może być całym programem lub jego częścią
	- 1 proces może być wykonywany przez 1 rdzeń jednocześnie
- **Wątki** - proces może (ale nie musi) dzielić się na wątki czyli mniejsze fragmenty procesu
- ![[Pasted image 20250803101913.png]]
	- docelowy proces może mieć pod sobą inne procesy, a te procesy mogą mieć pod sobą wątki
## Jakie są rodzaje procesów?
#background #foreground
- **background** - procesy w tle, systemowe, nie wymagają działania usera, nie są podpięte pod żaden aktywny terminal
- **foreground** - podpięty pod aktywny terminal, może wymagać aktywności usera; zamknięcie terminala spowoduje kill procesu

## Jakie są stany procesu?
#processstate #state
- **Running** - aktualnie wykonywany przez tryb użytkownika lub tryb jądra
- **Ready to run** - w kolejce, gotowy do wykonania
- **Waiting** - czeka na zewnętrzne zdarzenie, np. kliknięcie klawisza, odczyt pliku
- **Stopped** - zamrożony np. do debugowania, zazwyczaj za pomocą "sygnału do procesora"
	- specjalne sygnały do procesora, które są wysyłane do CPU poza kolejką, w jak najszybszym interwale
- **Zombie** - "zabity" proces, który nie został poprawnie zamknięty i usunięty z tablicy
## Czym jest PID i jak go sprawdzić?
#PID 
- Każdy proces ma swoje PID (Process ID), czyli własny numer ID
- **PID 1** to **systemd** (dawniej **init**), czyli nadrzędny proces zarządzający innymi procesami
- **pidof *nazwa_procesu*** - wyświetla PID
	- **UWAGA!** Pokaże PID tylko działającego procesu.
		- Jeśli zrobię pidof ls to nie dostanę nic, bo ten proces nigdzie teraz nie działa.
		- Jeśli zrobię tylko pidof ping to też nic nie dostanę, jeśli ping nie jest obecnie uruchomiony.
		- Jeśli uruchomię ping *URL* w innej powłoce, to wtedy pidof ping zwróci mi PID działającego procesu ping.

## Czym są i jakie są sygnały procesów?
#processsignal #signal
- Sygnały procesów służą do zatrzymania wykonywania się danego procesu.
- **kill -1 PID (SIGHUP 1)** - signal hangup, ponownie wczyta konfigurację tego procesu (aktualizacja) lub zamknie proces
- **kill -2 PID (SIGINT 2)** - signal interrupt, czeka na zakończenie obecnego procesu lub wątku i zamyka dalej proces, może wyczyścić po sobie pliki tymczasowe, zamknąć połączenia, itp.; **CTRL + C**
- **kill -3 PID (SIGQUIT 3)** - signal quit, wyjście z procesu i zrobienie zrzutu pamięci (przydatne w debugowaniu); **CTRL + \\**
- **kill -9 PID (SIGKILL 9)** - signal kill, force kill, czyli zamyka proces w tej chwili i niczego po sobie nie sprząta
- **kill -15 PID (SIGTERM 15), domyślny** - signal terminate, domyślny kill, po nim procesy zamykają się, zapisują dane, itd.; taki **grzeczny kill**
- **kill -20 PID (SIGSTP 20)** - signal stop, zatrzymuje proces, ale go nie kończy; **CTRL + Z**
	- wznowienie procesu: **kill -CONT PID**
- **UWAGA!** Każdy proces inaczej obsługuje różne rodzaje kill. Jeśli dany program nie ma własnej obsługi komend kill, to po prostu się zamknie. Jeśli ma, to zachowa się zgodnie z logiką programu.

## Jak wyświetlić listę aktywnych procesów?
#ps
- **ps** - zwraca listę aktywny procesów
	- sam ps zwróci tylko PID obecnej powłoki i PID komendy ps
	- **ps -aux** - zwróci informacje o wszystkich aktywnych procesach
		- **USER** - użytkownik, który uruchomił proces
		- **PID**
		- **%CPU** - procent użycia procesora przez proces
		- **%MEM** - procent użycia pamięci przez proces
		- **VSZ**- rozmiar wirtualnej pamięci zajmowanej przez proces (w KB)
		- **RSS** - rozmiar fizycznej pamięci zajmowanej przez proces (w KB)
		- **TTY** - powłoka na której działa proces
		- **STAT** - stan procesu (np. R - running)
		- **START** - godzina rozpoczęcia procesu
		- **TIME** - czas użycia procesora przez proces
		- **COMMAND** - nazwa lub ścieżka procesu
	- **ps -a** - wszystkie procesy terminali
	- **ps -ax** - wszystkie procesy poza terminalami
	- **ps -U *user*** - wszystkie procesy danego użytkownika

## Czym są procesy specjalne?
#daemon #service
- **Daemon** - proces działający w tle i wykonujący jakieś zadania ciągle lub na żądanie
	- działa samodzielnie
	- nie steruje się nim bezpośrednio, lecz za pomocą innych programów
	- np. **sshd** (połączenie ssh), **cron** (harmonogram), **syslogd** (monitorowanie, logi systemowe)
- **Service (usługa)** - sposób, w jaki mogę kontrolować proces działający w tle, np. **daemona**
	- pozwala na łatwe uruchamianie, zatrzymywanie, wznawianie i monitorowanie daemonów
	- np. **systemctl start sshd.service** - uruchomi tego daemona jako usługę

## Jak obsługiwać daemona?
#daemon #systemctl #service
- **service** - program do obsługi daemona
	- **service *nazwa_daemona* status / start / stop / restart** - wspomniane wcześniej uruchamianie, zatrzymywanie, wznawianie i monitorowanie daemonów

## Czym jest systemd?
#systemd
- **systemd** - to menedżer usług. Jest to taki nadrzędny system, który obsługuje wszystkie daemony i procesy działające w tle. Uruchamia je, monitoruje ich działanie i w razie problemów uruchamia je ponownie. **Jest trochę jak jądro systemu, z tym że w warstwie użytkownika.**
	- Odpowiada za: 
		- **uruchamia system** - włącza wszystkie niezbędne procesy i daemony w trakcie bootowania
		- **zarządza usługami** - czyli procesami działającymi w tle
		- **zarządza zależnościami między usługami** - np. najpierw uruchamia bazę danych, a potem program który z niej korzysta
		- **obsługa logów, urządzeń, sesji użytkowników, itp.**





[Kurs Linux](https://www.youtube.com/watch?v=MtACSbVxmig&list=PLpUS2q-4L9xx9P1SzadLKXGEY30yhVqYu&index=5) <- tu wrócić