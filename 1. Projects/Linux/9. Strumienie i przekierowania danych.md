#stream #redirection

## Czym jest pipe i jak go używać?
#pipe
- **komenda1 | komenda2**
	- najpierw dostaję wynik komendy1, ten wynik jest przekazywany do komendy2 i wtedy dostaję finalny wynik
	- np. **ls | grep m**
		- ls wyświetla listę plików, ale przekazuje tę listę jako tekst do komendy grep m i potem dostaję zwrócone wszystkie pliki które mają w swojej nazwie "m"
		- na czas wykonywania pipe jest tworzony w pamięci RAM bufor, który przechowuje dane z pierwszej komendy aby przekazać je do drugiej komendy

## Czym są strumienie danych?
#stdin #stdout #stderr
- Każdy uruchomiony program w Linux ma 3 strumienie danych:
	- **stdin 0** - strumień wejściowy
		- dane podawane przed uruchomieniem strumienia
	- **stdout 1** - strumień wyjściowy, bez błędów
	- **stderr 2** - strumień wyjściowy, w przypadku błędów
- **Jeśli komenda2 nie korzysta z stdin (np. touch) to przekazanie do niej czegokolwiek przez pipe nie zadziała**
	- w takim przypadku zadziała np. **ls | cat > test.txt**

## Jak przekierowywać dane?
#redirection 
- **0** - stdin
- **1** - stdout
- **2** - stderr
- **>** lub **1>** - nadpisuje dane dla stdout
- **2>** - nadpisuje dane dla stderr
- **>>** lub **1>>** - dopisuje dane (append) dla stdout
- **2>>** - dopisuje dane (append) dla stderr
- **&>** - nadpisuje dane zarówno dla stdout jak i stderr
- **&>>** - dopisuje dane zarówno dla stdout jak i stderr
	- przykłady dla powyższego:
		- **ls >> test.txt**
			- dopisze (append) wynik ls do pliku test.txt
		- **ls jakis_blad 2> test.txt**
			- nadpisze cały plik tekstem błędu, coś w stylu "ls: cannot access "jakis_blad": No such file or directory"
		- **WAŻNE!** Jeśli przykład wyżej przekaże się bez "2>" tylko w formie ">", to błąd pojawi się na konsoli, ale nie zostanie przekazany do pliku. Dlaczego? Bo użyłem strumienia dla stdout (1), a nie dla stderr (2). Gdybym użył 2> lub &> to błąd pojawiłby się jako tekst w pliku

## Do czego służy program "tee"?
#tee
- **tee** - przekierowuje strumień jednocześnie jako wynik terminala i do pliku lub innej komendy
	- **ping google.com | tee ping1.txt** - przekieruje stdout na konsolę oraz do pliku ping1.txt
	- **ping google.com | tee - a ping1.txt** - jak wyżej, ale nie nadpisuje danych do pliku, tylko dopisuje (append)
	- **ping google.com | tee ping1.txt ping2.txt** - na konsolę oraz do dwóch różnych plików
	- **ping google.com | tee ping1.txt | head -2** - wyświetlą się pierwsze 2 linie wyniku komendy ping google.com i te dwie linie zostaną zapisane do pliku ping1.txt
		- **ping google.com | tee ping1.txt | tail -2** - tutaj nie wyświetli się nic w terminalu, ale w pliku wszystko się będzie zapisywało poprawnie
			- różnica między powyższymi jest taka, że head odczytuje pierwsze 2 linie i zamyka stdin, co powoduje zamknięcie tee i całego pipeline; tail z kolei najpierw buforuje cały strumień, czyli czeka aż pojawią się ostatnie linie, ale z racji tego że ping działa w nieskończoność, to nigdy one się nie pojawią, więc na terminalu nie wyświetli się nic

## Jak działa xargs?
#xargs
- **xargs** - w strumieniu przyjmuje dane wyjściowe wcześniej wykonanego programu i przekazuje go do kolejnego programu z pipe w formie **argumentu**, a nie w formie strumienia.
	- **echo file1 file2 | rm** - nie zadziała, rm nie przyjmuje takiej formy danych wyjściowych jako argumentu
	- **echo file1 file2 | xargs rm** - to zadziała, przekazane dane wyjściowe zostaną potraktowane jako argument do rm