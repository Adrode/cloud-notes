#stream #redirection

## Czym jest pipe i jak go używać?
#pipe
- **komenda1 | komenda2**
	- najpierw dostaję wynik komendy1, ten wynik jest przekazywany do komendy2 i wtedy dostaję finalny wynik
	- np. **ls | grep m**
		- ls wyświetla listę plików, ale przekazuje tę listę jako tekst do komendy grep m i potem dostaję zwrócone wszystkie pliki które mają w swojej nazwie "m"
		- na czas wykonywania pipe jest tworzony w pamięci RAM bufor, który przechowuje dane z pierwszej komendy aby przekazać je do drugiej komendy

## Czym są strumienie danych?
#stdin #stdout #stderr
- Każdy uruchomiony program w Linux ma 3 strumienie danych:
	- **stdin 0** - strumień wejściowy
		- dane podawane przed uruchomieniem strumienia
	- **stdout 1** - strumień wyjściowy, bez błędów
	- **stderr 2** - strumień wyjściowy, w przypadku błędów
- **Jeśli komenda2 nie korzysta z stdin (np. touch) to przekazanie do niej czegokolwiek przez pipe nie zadziała**
	- w takim przypadku zadziała np. **ls | cat > test.txt**

## Jak przekierowywać dane?
#redirection 
- **0** - stdin
- **1** - stdout
- **2** - stderr
- **>** lub **1>** - nadpisuje dane dla stdout
- **2>** - nadpisuje dane dla stderr
- **>>** lub **1>>** - dopisuje dane (append) dla stdout
- **2>>** - dopisuje dane (append) dla stderr
- **&>** - nadpisuje dane zarówno dla stdout jak i stderr
- **&>>** - dopisuje dane zarówno dla stdout jak i stderr
	- przykłady dla powyższego:
		- **ls >> test.txt**
			- dopisze (append) wynik ls do pliku test.txt
		- **ls jakis_blad 2> test.txt**
			- nadpisze cały plik tekstem błędu, coś w stylu "ls: cannot access "jakis_blad": No such file or directory"
		- **WAŻNE!** Jeśli przykład wyżej przekaże się bez "2>" tylko w formie ">", to błąd pojawi się na konsoli, ale nie zostanie przekazany do pliku. Dlaczego? Bo użyłem strumienia dla stdout (1), a nie dla stderr (2). Gdybym użył 2> lub &> to błąd pojawiłby się jako tekst w pliku