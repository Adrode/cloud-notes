 #cut #sed #awk

## Do czego służy CUT?
#cut 
- **cut** - ekstraktuje zadany ciąg danych z pliku
	- **cut -c** - wyciąga znaki
		- **cut -c *1,2,3* *plik.txt*** - wyciągnie 1, 2 i 3 znak z każdej linii pliku
		- **cut -c *1-5* *plik.txt*** - wyciągnie od 1 do 5 znaku z każdej linii
		- **cut -c *3-* *plik.txt*** - od 3 znaku do końca
		- **cut -c *-3* *plik.txt*** - od początku do 3 znaku
	- **cut -f** - wyciąga dane oddzielone delimiterem
		- **delimiter** - znak, który oddzielna dane między sobą
			- coś jak tworzenie kolumn
		- standardowo w **cut -f** delimiterem jest **tab** i nie da się w tej opcji tego zmienić
			- jeśli w pliku dane będą oddzielone spacjami, to cut -f zawsze będzie pokazywał mi wszystkie dane
	- **cut -d** - wyciąga dane oddzielone delimiterem, który można samodzielnie ustalić
		- **cut -d  " " -f 2 *plik.txt*** - wyciągnie dane z **2giej kolumny**

## Do czego służy SED?
#sed 
- **sed** - **edytor strumieniowy**, zaawansowana** komenda do edycji danych z pliku z poziomu terminala
	- standardowo nie zmienia danych bezpośrednio w pliku, tylko przechowuje dane z pliku w pamięci i je modyfikuje
	- **sed s/*szukane_słowo*/*nowe_słowo*/ *plik.txt*** - wyszukuje w całym pliku zadanego ciągu znaków i podmienia je na nowy, podany ciąg znaków
		- **działa tylko na pierwszym wyszukanym stringu w danej linii**
	- **sed s/.../.../2 *plik.txt*** - cyfra na końcu podanych stringów określa które wyszukanie ma zostać zamienione
		- **sed s/.../.../g *plik.txt*** - global, czyli wszystkie wyszukania zostaną zamienione
		- **sed s/.../.../2g *plik.txt*** - globalnie, ale od drugiego wyszukania
	- **sed "2 s/.../.../g" plik.txt** - delimiter wertykalny, czyli 2 na początku oznacza wybraną linię; jeśli w tej linii nie będzie szukanej frazy, to niczego nie zmieni; **musi być w cudzysłowie**
		- **sed "2,$ s/.../.../g" plik.txt** - od drugiej linii do końca
		- **sed "2,4 s/.../.../g" plik.txt** - od drugiej do czwartej linii
	- **sed -n s/.../.../p plik.txt** - **przełącznik "-n" ze znakiem "p" po ostatnim delimiterze**, pokaże tylko linie, w których doszła zmiana
	- **sed 5d plik.txt** - usuwa wskazaną linię, w tym przypadku linię 5
		- **sed 5,10d plik.txt** - usunie od 5 do 10 linii
		- **sed /*szukany_ciąg*/d plik.txt** - usunie linie zawierające zadaną frazę
	- **sed -i /.../ plik.txt** - dokonuje zmian bezpośrednio w pliku, poprzez opcję **-i**

## Do czego służy AWK?
#awk 
- **awk** - język skryptowy do manipulacji danymi i do generowania raportów; jest to pełny język programowania, więc poniższe opcje to tylko podstawy na temat działania awk
	- **awk opcje 'kryteria_wyboru {akcja}' plik_wejścia > plik_wyjścia** -  składnia
		- **awk '{print}' plik.txt** - bardzo podstawowa opcja, wyświetlenie zawartości pliku na terminal 
		- **awk '{print $1,$3}' plik.txt** - wyświetli zadane **kolumny** z pliku (kolumny, nie wiersze/linie)
		- **awk '/*kryterium*/ {print}' plik.txt** - wyświetlenie tylko linii z szukaną frazą/kryterium

## Jak działa zaawansowana składnia AWK?
#BEGIN #END
- **blok BEGIN** - pozwala na zrobienie czegoś przez awk, zanim ten zacznie czytać plik/strumień
	- przydatne do wypisania nagłówka albo ustawienia FS, RS, OFS, ORS
	- **awk 'BEGIN {print ...}...**
- **standardowa składnia** - to co ma się wykonać na pliku
	- **... {print ...}...**
- **blok END** - pozwala na zrobienie czegoś po zamknięciu strumienia wejściowego
	- przydatne do wypisania stopki lub jakiegoś podsumowania dancych
	- **... END {print ...}' plik.txt**
- przykład:
	- **awk 'BEGIN {print "START!"} {print} END {print "FIN!"}' cars.txt**
		- w pierwszej linii będzie START!, w kolejnych liniach zawartość pliku cars.txt, a w ostatniej linii FIN!

## Jak działają wbudowane zmienne AWK?
#NR #NF #FS #RS #OFS #ORS
- Zasada użycia: po akcji wpisuje się nazwę zmiennej
	- **{action ZMIENNA}**
- Rodzaje zmiennych:
	- **NR** - numer rzędu pliku wejściowego
		- np. **awk '{print NR}' plik.txt** - wyświetli wszystkie numery linii z pliku (tylko numery)
		- **awk '{print NR ": " $1}' plik.txt** - wyświetli numery linii oraz dane z pierwszej kolumny
			- **": "** - znak dwukropka, by oddzielić od siebie kolumny
	- **NF** - liczba pól każdego rzędu pliku wejściowego
		- czyli coś jak liczba komórek; jeśli mam w jedynym rzędzie 5 stringów (kolumn, oddzielonych tym samym separatorem, np. " "), to NF zwróci mi liczbę 5
	- **FS** - przechowuje separator pól (domyślnie dowolna liczba spacji lub tab), **czyli to co awk uznaje za separator linii**
		- gdybym w pliku miał separator jako "," lub dowolny inny znak, to mogę zrobić tak:
			- **awk '{FS=","} {print NF}' plik.txt** - to da wynik liczby pól / komórek, a bez FS, gdy separatorem jest w pliku ",", ale awk o tym nie wie, to poda mi liczbę pól / komórek równą 1
	- **RS** - przechowuje separator linii (domyślnie znak nowej linii /n), **czyli to co awk uznaje za koniec rekordu (czyli koniec linii)**
		- **awk '{RS=""} {print $1}' plik.txt** - w tym przypadku "" oznacza pustą linię/rekord, więc to pusta linia będzie separatorem
	- **OFS** - przechowuje separator pól, którym rozdzielane są dane na wyjściu, **czyli to czym awk rozdzieli kolumny podając dane wyjściowe**
		- **awk '{OFS=" - "} {print $1,$2}' plik.txt** - każda kolumna na wyjściu będzie oddzielona znakami " - "
	- **ORS** - przechowuje separator linii, którym rozdzielane są linie na wyjściu, **czyli to czym awk rozdzieli rekordy / linie**
		- **awk '{ORS=", "} {print}' plik.txt** - każdy rekord nie będzie już oddzielony znakiem nowej linii (/n), tylko przecinkiem




[Kurs Linux](https://www.youtube.com/watch?v=_YsT8IGVxAs&list=PLpUS2q-4L9xx9P1SzadLKXGEY30yhVqYu&index=6) <- tu wrócić