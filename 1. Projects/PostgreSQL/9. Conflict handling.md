#conflict_handling
## Na czym polega obsłużenie konfliktu?
#conflict_handling
- Podobnie jak w Pythonie, obsługuje się konflikt aby zamiast błędu aplikacji otrzymać określone w kodzie zachowanie

## Jak działa upsert?
#upsert 
- **Upsert** - Update od Insert, używany np. poprzez ON CONFLICT ... DO UPDATE (niżej); polega na tym, że jeśli zostanie wyłapany conflict, to ten wiersz jest update'owany a jeśli conflictu nie ma, to robi się zwykły insert
	- przykład: robię insert koszyka produktów klienta, czyli kolumny `(user_id, product_id, quantity)` i robię składnię `INSERT INTO ...`, a na koniec daję `ON CONFLICT (user_id) DO UPDATE SET ...`, czyli jeśli już jest taki użytkownik, to zaktualizuj jego koszyk; jeśli nie ma takiego użytkownika, to utwórz nowy wpis

## Jak działa ON CONFLICT ... DO NOTHING?
#ON_CONFLICT #DO_NOTHING
- **`INSERT INTO person (id, ...) VALUES (1, ...) ON CONFLICT (id) DO NOTHING;`** - przy konflikcie duplicate key (tutaj jeśli podaję ręcznie id, a id jest autoincrement, to dostanę wymieniony błąd) dostanę `INSERT 0 0`, czyli zgodnie z określonym zachowaniem `DO NOTHING`, program nie zwróci błędu, ale też niczego nie zrobi
	- mogę zrobić to samo podając `ON CONFLICT (email) DO NOTHING;`, żeby obsłużyć błędy przy email duplicate
	- jeśli zrobię `ON CONFLICT (first_name) DO NOTHING;`, gdzie na first_name nie mam ustawionego żadnego constrainta, to dostanę błąd, ponieważ ON CONFLICT działa tylko na kolumnach które mają constrainty

## Jak działa ON CONFLICT ... DO UPDATE?
#ON_CONFLICT #DO_UPDATE
- **`INSERT INTO person (..., email) VALUES (..., 'adwoz@gmail.com') ON CONFLICT (email) DO UPDATE SET email = EXCLUDED.email;`** - `email` odnosi się do wartości obecnej w tabeli, `EXCLUDED.email` odnosi się do wartości podanej w poleceniu
	- z racji tego że kolumna email jest `UNIQUE`, to jeśli próbujemy dodać już istniejący email, to wtedy będzie conflict - skoro będzie conflict, to DO UPDATE czyli update wpisu o dane podane w komendzie
	- jeśli nie ma konfliktu, to po prostu zadziała zwykły INSERT
