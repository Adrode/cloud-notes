#MRO
## Czym jest MRO?
#MRO
- **MRO (Method Resolution Order)** - określa kolejność, w jakiej Python szuka metod i atrybutów w hierarchii klas
	- dla klasy `Mage(Character, HasDOT)` MRO wygląda tak: `Mage -> Character -> HasDOT -> object`
	- jeśli każda klasa ma własny konstruktor (`__init__()`), najlepiej aby wywoływała `super().__init__(...)`, dzięki czemu wszystkie konstruktory z hierarchii zostaną wywołane
		- `Mage` `super().__init__()` odwołuje się do konstruktora klasy `Character`
		- `Character` `super().__init__()` odwołuje się do konstruktora klasy `HasDOT`
		- `HasDOT` `super().__init__()` odwołuje się do konstruktora `object`
			- jeśli gdzieś zabraknie `super().__init__()` to łańcuch MRO zostanie przerwany i kolejne konstruktory nie zostaną przekazane
			- ew. można wywoływać konstruktory „ręcznie”, np. `HasDOT.__init__(self)`, ale w hierarchiach wielokrotnego dziedziczenia jest to mniej skalowalne i może prowadzić do bałaganu.

## Czym jest i jak używać \*args i \*\*kwargs?
#\*args #\*\*kwargs
- **\*args** - przechowuje dowolną liczbę positional arugments, w formie krotki
- **\*\*kwargs** - przechowuje dowolną liczbę keyword arguments, w formie dict
	- są przydatne przy dziedziczeniu i przekazywaniu argumentów między klasami, kiedy nie wiadomo dokładnie ile argumentów będzie przekazanych do funkcji lub konstruktora
		- jeśli projekt ma być skalowalny i wiele klas dziedziczy po sobie, to \*args i \*\*kwargs jest przydatne, żeby nie pogubić się w dziedziczeniu argumentów