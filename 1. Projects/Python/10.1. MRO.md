#MRO
## Czym jest MRO?
#MRO
- **MRO (Method Resolution Order)** - określa kolejność, w jakiej Python szuka metod i atrybutów w hierarchii klas
	- dla klasy `Mage(Character, HasDOT)` MRO wygląda tak: `Mage -> Character -> HasDOT -> object`
	- jeśli każda klasa ma własny konstruktor (`__init__()`), najlepiej aby wywoływała `super().__init__(...)`, dzięki czemu wszystkie konstruktory z hierarchii zostaną wywołane
		- `Mage` `super().__init__()` odwołuje się do konstruktora klasy `Character`
		- `Character` `super().__init__()` odwołuje się do konstruktora klasy `HasDOT`
		- `HasDOT` `super().__init__()` odwołuje się do konstruktora `object`
			- jeśli gdzieś zabraknie `super().__init__()` to łańcuch MRO zostanie przerwany i kolejne konstruktory nie zostaną przekazane
			- ew. można wywoływać konstruktory „ręcznie”, np. `HasDOT.__init__(self)`, ale w hierarchiach wielokrotnego dziedziczenia jest to mniej skalowalne i może prowadzić do bałaganu.
	- **PRZYKŁAD:**
		- klasa Rouge przyjmuje 7 argumentów (z czego 1 argumentem jest `self`) i dziedziczy po Character, który przyjmuje 4 argumentów oraz po HasCRIT, który przyjmuje 2 argumenty
			- tutaj nie wystarczy, że każda klasa będzie miała w swoich kosntrukotrach `super().__init__()`, ponieważ:
				- **super().__init__()** w Rouge przekazuje 7 argumentów do Character, a Character zna tylko 4 z tych argumentów, a pozostałych 2 nie zna i nie przekaże ich do HasCRIT, bo:
					- **nie zakłada, że pozostałe argumenty ma gdzieś przekazać**
					- **założenie w MRO jest takie, że każda kolejna klasa łańcucha MRO wie co ma zrobić ze wszsytkimi argumentami**
			- **`super()` nie dopasowuje argumentów do klas w łańcuchu, tylko przekazuje je do kolejnej klasy bez analizy**
				- żeby rozwiązać problem, czyli  **przekazać pozostałe argumenty dalej w łańuchu MRO**, potrzebne jest przekazanie do Rogue, Character i HasCRIT **\*args** i **\*\*kwargs**
					- **\*args i \*\*kwargs to sposób, by umożliwić klasom pobranie tylko tego, czego potrzebują, i odesłanie reszty dalej w MRO

## Czym jest i jak używać \*args i \*\*kwargs?
#\*args #\*\*kwargs
- **\*args** - przechowuje dowolną liczbę positional arugments, w formie krotki
- **\*\*kwargs** - przechowuje dowolną liczbę keyword arguments, w formie dict
	- są przydatne przy dziedziczeniu i przekazywaniu argumentów między klasami, kiedy nie wiadomo dokładnie ile argumentów będzie przekazanych do funkcji lub konstruktora
		- jeśli projekt ma być skalowalny i wiele klas dziedziczy po sobie, to \*args i \*\*kwargs jest przydatne, żeby nie pogubić się w dziedziczeniu argumentów