#object_oriented_programming #oop
## Czym jest programowanie obiektowe?
#object_oriented_programming 
- W Python **wszystko jest obiektem**.
- **Programowanie obiektowe** to sposób myślenia o kodzie.
- Opiera się na **obiektach**, które łączą dane (**atrybuty**) i logikę/funkcje (**metody**)
	- Uporządkowuje to kod
	- Ułatwia zrozumienie kodu

## Jak utworzyć klasę i obiekt?
#class #object
```python
class User: # klasa
	def __init__(self, name, age): # konstruktor
		self.name = name
		self.age = age
	
	def print_info(self): # metoda
		print(self.name)
		print(self.age)
	
	def is_male(self): # metoda
		print(self.name[-1:] != 'a') # True lub False
		
person = User('Adrian', 25) # instancja

person.print_info() #wywołanie metody dla obiektu person
```
- **class *Nazwa*:**
	- klasa, czyli przepis na podstawie którego można utworzyć instancję, czyli obiekt
- **def __init__(self):**
	- **konstruktor**, który ustala początkowy stan dla obiektu
	- jeśli ma podane parametry, to do utworzenia instancji wymagane będzie podanie atrybutów
- **atrybut**
	- zmienna należąca do obiektu
- **metoda**
	- funkcja należąca do obiektu
	- zawsze jako pierwszy argument ma self
- **self**
	- odwołanie do konkretnej instancji, czyli:
		- ```python
		def print_info(self): # metoda
			print(self.name)
			print(self.age)
		
		person.print_info()
		```
		- **self** oznacza "odnieś się w tej funkcji do danych z instancji **person**"
- **instancja**
	- utworzenie obiektu na podstawie podanej klasy
- **wywołanie**
	- np. użycie metody `person.print_info()**`

## Jak importować dane z innego pliku?
#import
- **`from *nazwa_pliku* import *nazwa_klasy*`**
	- ten wpis dodaję na początku pliku w którym potrzebuję danych z innego pliku
	- mogę wyrzucić class do innego pliku i je importować, jeśli są potrzebne w różnych miejscach

## Czym są i jak korzystać z class variables?
#class_variables
- ```python
  class Car:
	  author = "Adrian W."
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
	  
	  def about_author(self):
		  print(f"Author is: {self.author}") # użycie class variable do metody
	
  car1 = Car("Cruze", 2010)
  
  print(car1.author) # tak raczej nie robić
  print(Car.author) # tak robić; wyjaśnienie niżej
  ```
	- każdy utworzony obiekt (instancja) ma dostęp do zmiennej `author`, która jest wspólna dla wszystkich obiektów
	- tworzone są **poza konstruktorem**
	- jak chcemy wyświetlić albo skorzystać z class variable, to raczej odnosimy się do niej przez klasę (`Car.author`)  niż przez obiekt (`car1.author`)
		- dobierając się do zmiennej przez car1, gdybym nie widział struktury klasy Car, to nie mógłbym rozróżnić czy jest to atrybut czy zmienna klasowa
		- korzystanie z takiej formy: `Car.author` jest dobrą praktyką i jest dużo bardziej czytelne
- ```python
  class Car:
	  num_cars = 0
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
		  Car.num_cars += 1
		  ...
	  ...
  ```
	- przy każdym utworzeniu nowego obiektu zwiększa się "licznik" liczby obiektów
	- wew. klasy też trzeba odnosić się w ten sposób: `Car.num_cars`, inaczej nie będzie to działało

## Jak działa dziedziczenie?
#inheritance
- **Dziedziczenie** polega na przekazaniu do klasy-dziecka atrybutów i metod klasy-rodzica.
	- zapewnia większe możliwości ponownego użycia klas i obiektów
- ```python
  class Animal:
	  def __init__(self, name):
		  self.name = name
		  self.is_alive = True
		  
	  def sleep(self):
		  print(f"{self.name} is sleeping")
		  
  class Dog(Animal): # inheritance
	  pass
	  
  class Cat(Animal): # inheritance
	  def speak(self): # metoda dostępna tylko dla obiektu klasy Cat
		  print("MEOW!")
	
  dog = Dog("Scooby")
  cat = Cat("Tom")
  ```
	- `class Klasa_dziecko(Klasa_rodzic):`
		- `def dodatkowe_metody_lub_atrybuty_klasy_dziecka()`
		- taka jest składnia dziedziczenia

## Jak działa wielokrotne dziedziczenie?
#multiple_inheritance #multilevel_inheritance
- **Multiple** - dziedziczenie od 2 lub większej liczby rodziców:
	- ```python
	  class Prey:
		  def flee(self):
			  print("This animal is running away")
	  
	  class Predator:
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Prey, Predator): # multiple inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.flee()
	  fish.hunt() # obie metody zadziałają
			  
	  ```
- **Multilevel** - dziedziczenie od rodzica, który już dziedziczy coś od rodzica
	- ```python
	  class Animal:
		  def eat(self):
			  print("This animal is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Predator): # multilevel inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.eat()
	  fish.hunt() # obie metody zadziałają
	  ```
- **Dziedziczenie atrybutów**:
	- ```python
	  class Animal:
		  def eat(self):
			  print(f"{self.name} is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print(f"{self.name} is hunting")
			  
	  class Fish(Predator):
		  def __init__(self, name):
			  self.name = name
		  
	  fish = Fish("Rypka")
	  
	  fish.eat()
	  fish.hunt()
	  ```
	- nie ma znaczenia na którym poziomie zostanie zdefiniowany konstruktor, najważniejsze żeby się nie powtarzały w ramach dziedziczonych klas

## Czym są klasy abstrakcyjne i jak się ich używa?
#abstract_class
- **Abstract class** - jest klasą, która **nie jest** przeznaczona do bezpośredniego tworzenia obiektów
	- służy np. jako interfejs dla grupy klas
	- można wymusić, żeby każda klasa potomna miała pewne metody, ale jednocześnie te potomne klasy mają swobodę w implementacji tych metod

- `from abc import ABC, abstractmethod`
	- `abc` - abstract base **classes**
	- `ABC` - abstract base **class**
- **ABC (Abstract Base Class)** - to tylko baza, która umożliwia stworzenie klasy abstrakcyjnej. Do stworzenia prawdziwej klasy abstrakcyjnej potrzebne jest zdefiniowanie dla takiej klasy **@abstractmethod**
- **@abstractmethod** - definiuje metodę klasy abstrakcyjnej:
	- można zdefiniować działanie metody w ciele klasy abstrakcyjnej
	- można wymusić konieczność zdefiniowania metody na klasie, która będzie dziedziczyła po klasie abstraktyjnej:
		- ```python
		  class Shape(ABC):
			  @abstractmethod
			  def area(self):
				  pass
				  
		  class Square(Shape):
			  def __init__(self, length):
				  self.length = length
				  
			  def area(self):
				  print(f"Square area: {self.length ** 2}")
		  ```

## Czym są superclass i jak korzystać z funkcji super()?
#superclass 
- **`super()`** - funkcja wykorzystywana w klasie-dziecku aby wywołać metodę klasy-rodzica
	- pozwala na rozszerzenie funkcjonalności dziedziczonych metod
	- wykorzystywane jest przy inheritance, aby nie musieć powtarzać tych samych atrybutów w różnych klasach (czyli *reusability*)
	- **przy dziedziczeniu multilevel i multiple, dzięki super(), nie powtarzają się wywołania atrybutów i metod; jest to zachowane dzięki MRO (Method Resolution Order), który zapewnia że każda klasa nadrzędna zostaje uwzględniona przy dziedziczeniu dokładnie raz
- ```python
  class Shape: # superclass
	  def __init__(self, color, is_filled):
		  self.color = color
		  self.is_filled = is_filled
		  
  class Circle(Shape): #subclass
	  def __init__(self, color, is_filled, radius):
		  super().__init__(color, is_filled)
		  self.radius = radius
	
  class Triangle(Shape): #subclass
	  def __init__(self, color, is_filled, width, height):
		  super().__init__(color, is_filled)
		  self.width = width
		  self.height = height
		  
  triangle = Triangle("blue", True, 5, 10)
  
  print(triangle.color)
  print(triangle.width)
  ```
	- `super().__init__(color, is_filled)` - tutaj `__init__()` odnosi się do wskazania na konstruktor rodzica i pobranie z niego zadanych atrybutów
	- `superclass` - klasa-rodzic
	- `subclass` - klasa-dziecko
- ```python
  class Message:
	  def __init__(self, text):
		  self.text = text
		  
	  def print_info(self):
		  print(f"Message info: {self.text}")
		  
  class Success(Message):
	  def print_info(self):
		  super().print_info()
		  print(f"Message has been sent")
  ```
	- `super()` przy dziedziczeniu metod polega na rozszerzeniu funkcjonalności danej metody
		- nie tworzy zupełnie nowej metody, tylko dziedziczy funkcjonalność metody z superclass i rozszerza ją

## Czym jest polimorfizm i jak go używać?
#polymorphism
- **poly** - wiele, **morphe** - forma
	- czyli polimorfizm to wiele form
- ```python
  from abc import ABC, abstractmethod
  
  class Animal(ABC):
	  @abstractmethod
	  def speak(self):
		  pass
		  
  class Dog(Animal):
	  def speak(self):
		  print("Woof!")
		  
  class Cat(Animal):
	  def speak(self):
		  print("Meow!")
		  
  class Persian(Cat):
	  def speak(self):
		  print("Meow! *in persian*")
		  
  animals = [Dog(), Cat(), Persian()] # ten zapis właśnie realizuje polimorfizm
  
  for animal in animals:
	  animal.speak()
  ```
	- **polimorfizm** polega na tym, że jeżeli klasy mają wspólną strukturę lub metody to mogą być traktowane grupowo

## Czym jest i na czym polega duck typing?
#duck_typing
- ***If it quacks like a duck and walks like a duck - it's a duck.**
- ```python
  class Duck:
	  def speak(self):
		  print("Quack!")

  class Car:
	  def speak(self):
		  print("Honk!")
		  
  animals = [Duck(), Car()]
  
  for animal in animals:
	  animal.speak()
  ```
- Działa jak polimorfizm, ale trochę uproszczony, czyli niezależnie od dziedziczenia i "pochodzenia" klasy - jeśli metody w klasach są te same, to można je grupować.

## Czym jest i jak używać aggregation?
#aggregation
- **aggregation** - relacja, gdzie jeden obiekt (jako całość) zawiera odniesienia do jednego lub większej liczby innych, niezależnych obiektów (jako części)
	- relacja typu **has-a**
		- czyli jak wynajmowanie czegoś
- ```python
  class Library:
	  def __init__(self, name):
		  self.name = name
		  self.books = []
		  
	  def add_book(self, book):
	  # dodawanie części elementów, które należą do klasy Books
		  self.books.append(book)
		  
	  def list_books(self):
	  # wyświetlanie elementów na podstawie atrybutów innej klasy
		  for book in self.books:
			  print(f"{book.name}, by {book.author}")
  class Book:
	  def __init__(self, title, author):
		  self.title = title
		  self.author = author
		  
  library = Library("Wrocławska Biblioteka")
  
  book1 = Book("Wieża jaskółki", "Andrzej Sapkowski")
  book2 = Book("Pan Lodowego Ogrodu, tom 1", "Jarosław Grzędowicz")
  
  library.add_book(book1)
  library.add_book(book2)
  library.list_books()
  ```
	- powyższy przykład pokazuje **dwie, niezależne od siebie klasy** (czyli mogą istnieć bez siebie nawzajem), w których **jedna klasa wykorzystuje elementy innej klasy**

## Czym jest i jak używać composition?
#composition
- **composition** - relacja, gdzie obiekt korzysta z elementów innych obiektów, ale nie może funkcjonować bez tych obiektów
	- relacja typu **owns-a**
		- czyli jak bycie właścicielem
- ```python
  class Engine:
	  def __init__(self, horse_power):
		  self.horse_power = horse_power
  
  class Wheel:
	  def __init__(self, size):
		  self.size = size
		  
  class Car: # klasa nadrzędna, która potrzebuje klas podrzędnych żeby istnieć
	  def __init__(self, model, horse_power, size):
		  self.model = model
		  self.hp = Engine(horse_power) # to jest praktyczna realizacja composition
		  self.wheel_size = Wheel(size)
		  
	  def print_info(self):
		  print(f"Model: {self.model}, HP: {self.hp.horse_power}, wheel size:{self.wheel_size.size})
  ```
	- konstruktor wymaga atrybutu `wheel_size` do której jest przypisany `size` z klasy `Wheel`, więc żeby mogła powstać klasa `Car`, potrzebne jest istnienie klasy `Wheel`; tak samo z `Engine`
		- `Wheel` i `Engine` mogą istnieć bez `Car`, ale w drugą stronę już to nie działa
	- `self.hp = Engine(horse_power)` - zadeklarowanie atrybutu z koniecznością użycia atrybutu z innej klasy
	- `self.hp.horse_power` - otrzymanie zawartości atrybutu

[Python docs](https://docs.python.org/3/tutorial/introduction.html)
[Python OOP](https://www.youtube.com/watch?v=IbMDCwVm63M) <- tu wrócić (01:22:00)