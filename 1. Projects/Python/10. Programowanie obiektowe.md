#object_oriented_programming #oop
## Czym jest programowanie obiektowe?
#object_oriented_programming 
- W Python **wszystko jest obiektem**.
- **Programowanie obiektowe** to sposób myślenia o kodzie.
- Opiera się na **obiektach**, które łączą dane (**atrybuty**) i logikę/funkcje (**metody**)
	- Uporządkowuje to kod
	- Ułatwia zrozumienie kodu

## Jak utworzyć klasę i obiekt?
#class #object
```python
class User: # klasa
	def __init__(self, name, age): # konstruktor
		self.name = name
		self.age = age
	
	def print_info(self): # metoda
		print(self.name)
		print(self.age)
	
	def is_male(self): # metoda
		print(self.name[-1:] != 'a') # True lub False
		
person = User('Adrian', 25) # instancja

person.print_info() #wywołanie metody dla obiektu person
```
- **class *Nazwa*:**
	- klasa, czyli przepis na podstawie którego można utworzyć instancję, czyli obiekt
- **def __init__(self):**
	- **konstruktor**, który ustala początkowy stan dla obiektu
	- jeśli ma podane parametry, to do utworzenia instancji wymagane będzie podanie atrybutów
- **atrybut**
	- zmienna należąca do obiektu
- **metoda**
	- funkcja należąca do obiektu
	- zawsze jako pierwszy argument ma self
- **self**
	- odwołanie do konkretnej instancji, czyli:
		- ```python
		def print_info(self): # metoda
			print(self.name)
			print(self.age)
		
		person.print_info()
		```
		- **self** oznacza "odnieś się w tej funkcji do danych z instancji **person**"
- **instancja**
	- utworzenie obiektu na podstawie podanej klasy
- **wywołanie**
	- np. użycie metody `person.print_info()**`

## Jak importować dane z innego pliku?
#import
- **`from *nazwa_pliku* import *nazwa_klasy*`**
	- ten wpis dodaję na początku pliku w którym potrzebuję danych z innego pliku
	- mogę wyrzucić class do innego pliku i je importować, jeśli są potrzebne w różnych miejscach

## Czym są i jak korzystać z class variables?
#class_variables
- ```python
  class Car:
	  author = "Adrian W."
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
	  
	  def about_author(self):
		  print(f"Author is: {self.author}") # użycie class variable do metody
	
  car1 = Car("Cruze", 2010)
  
  print(car1.author) # tak raczej nie robić
  print(Car.author) # tak robić; wyjaśnienie niżej
  ```
	- każdy utworzony obiekt (instancja) ma dostęp do zmiennej `author`, która jest wspólna dla wszystkich obiektów
	- tworzone są **poza konstruktorem**
	- jak chcemy wyświetlić albo skorzystać z class variable, to raczej odnosimy się do niej przez klasę (`Car.author`)  niż przez obiekt (`car1.author`)
		- dobierając się do zmiennej przez car1, gdybym nie widział struktury klasy Car, to nie mógłbym rozróżnić czy jest to atrybut czy zmienna klasowa
		- korzystanie z takiej formy: `Car.author` jest dobrą praktyką i jest dużo bardziej czytelne
- ```python
  class Car:
	  num_cars = 0
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
		  Car.num_cars += 1
		  ...
	  ...
  ```
	- przy każdym utworzeniu nowego obiektu zwiększa się "licznik" liczby obiektów
	- wew. klasy też trzeba odnosić się w ten sposób: `Car.num_cars`, inaczej nie będzie to działało

## Jak działa dziedziczenie?
#inheritance
- **Dziedziczenie** polega na przekazaniu do klasy-dziecka atrybutów i metod klasy-rodzica.
	- zapewnia większe możliwości ponownego użycia klas i obiektów
- ```python
  class Animal:
	  def __init__(self, name):
		  self.name = name
		  self.is_alive = True
		  
	  def sleep(self):
		  print(f"{self.name} is sleeping")
		  
  class Dog(Animal): # inheritance
	  pass
	  
  class Cat(Animal): # inheritance
	  def speak(self): # metoda dostępna tylko dla obiektu klasy Cat
		  print("MEOW!")
	
  dog = Dog("Scooby")
  cat = Cat("Tom")
  ```
	- `class Klasa_dziecko(Klasa_rodzic):`
		- `def dodatkowe_metody_lub_atrybuty_klasy_dziecka()`
		- taka jest składnia dziedziczenia

## Jak działa wielokrotne dziedziczenie?
#multiple_inheritance #multilevel_inheritance
- **Multiple** - dziedziczenie od 2 lub większej liczby rodziców:
	- ```python
	  class Prey:
		  def flee(self):
			  print("This animal is running away")
	  
	  class Predator:
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Prey, Predator): # multiple inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.flee()
	  fish.hunt() # obie metody zadziałają
			  
	  ```
- **Multilevel** - dziedziczenie od rodzica, który już dziedziczy coś od rodzica
	- ```python
	  class Animal:
		  def eat(self):
			  print("This animal is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Predator): # multilevel inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.eat()
	  fish.hunt() # obie metody zadziałają
	  ```
- **Dziedziczenie atrybutów**:
	- ```python
	  class Animal:
		  def eat(self):
			  print(f"{self.name} is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print(f"{self.name} is hunting")
			  
	  class Fish(Predator):
		  def __init__(self, name):
			  self.name = name
		  
	  fish = Fish("Rypka")
	  
	  fish.eat()
	  fish.hunt()
	  ```
	- nie ma znaczenia na którym poziomie zostanie zdefiniowany konstruktor, najważniejsze żeby się nie powtarzały w ramach dziedziczonych klas

## Czym są klasy abstrakcyjne i jak się ich używa?
#abstract_class
- **Abstract class** - jest klasą, która **nie jest** przeznaczona do bezpośredniego tworzenia obiektów
	- służy np. jako interfejs dla grupy klas
	- można wymusić, żeby każda klasa potomna miała pewne metody, ale jednocześnie te potomne klasy mają swobodę w implementacji tych metod

- `from abc import ABC, abstractmethod`
	- `abc` - abstract base **classes**
	- `ABC` - abstract base **class**
- **ABC (Abstract Base Class)** - to tylko baza, która umożliwia stworzenie klasy abstrakcyjnej. Do stworzenia prawdziwej klasy abstrakcyjnej potrzebne jest zdefiniowanie dla takiej klasy **@abstractmethod**
- **@abstractmethod** - definiuje metodę klasy abstrakcyjnej:
	- można zdefiniować działanie metody w ciele klasy abstrakcyjnej
	- można wymusić konieczność zdefiniowania metody na klasie, która będzie dziedziczyła po klasie abstraktyjnej:
		- ```python
		  class Shape(ABC):
			  @abstractmethod
			  def area(self):
				  pass
				  
		  class Square(Shape):
			  def __init__(self, length):
				  self.length = length
				  
			  def area(self):
				  print(f"Square area: {self.length ** 2}")
		  ```

## Czym są superclass i jak korzystać z funkcji super()?
#superclass 
- **`super()`** - funkcja wykorzystywana w klasie-dziecku aby wywołać metodę klasy-rodzica
	- pozwala na rozszerzenie funkcjonalności dziedziczonych metod
	- wykorzystywane jest przy inheritance, aby nie musieć powtarzać tych samych atrybutów w różnych klasach (czyli *reusability*)
	- **przy dziedziczeniu multilevel i multiple, super() służy do wywoływania kolejnego w hierarchii MRO konstruktora**
		- **nie służy do przekazywania argumentów!, tylko do połączenia łańcucha klas zgodnie z MRO** ([[10.1. MRO]])
- ```python
  class Shape: # superclass
	  def __init__(self, color, is_filled):
		  self.color = color
		  self.is_filled = is_filled
		  
  class Circle(Shape): #subclass
	  def __init__(self, color, is_filled, radius):
		  super().__init__(color, is_filled)
		  self.radius = radius
	
  class Triangle(Shape): #subclass
	  def __init__(self, color, is_filled, width, height):
		  super().__init__(color, is_filled)
		  self.width = width
		  self.height = height
		  
  triangle = Triangle("blue", True, 5, 10)
  
  print(triangle.color)
  print(triangle.width)
  ```
	- `super().__init__(color, is_filled)` - tutaj `__init__()` odnosi się do wskazania na konstruktor rodzica i pobranie z niego zadanych atrybutów
	- `superclass` - klasa-rodzic
	- `subclass` - klasa-dziecko
- ```python
  class Message:
	  def __init__(self, text):
		  self.text = text
		  
	  def print_info(self):
		  print(f"Message info: {self.text}")
		  
  class Success(Message):
	  def print_info(self):
		  super().print_info()
		  print(f"Message has been sent")
  ```
	- `super()` przy dziedziczeniu metod polega na rozszerzeniu funkcjonalności danej metody
		- nie tworzy zupełnie nowej metody, tylko dziedziczy funkcjonalność metody z superclass i rozszerza ją

## Czym jest polimorfizm i jak go używać?
#polymorphism
- **poly** - wiele, **morphe** - forma
	- czyli polimorfizm to wiele form
- ```python
  from abc import ABC, abstractmethod
  
  class Animal(ABC):
	  @abstractmethod
	  def speak(self):
		  pass
		  
  class Dog(Animal):
	  def speak(self):
		  print("Woof!")
		  
  class Cat(Animal):
	  def speak(self):
		  print("Meow!")
		  
  class Persian(Cat):
	  def speak(self):
		  print("Meow! *in persian*")
		  
  animals = [Dog(), Cat(), Persian()] # ten zapis właśnie realizuje polimorfizm
  
  for animal in animals:
	  animal.speak()
  ```
	- **polimorfizm** polega na tym, że jeżeli klasy mają wspólną strukturę lub metody to mogą być traktowane grupowo

## Czym jest i na czym polega duck typing?
#duck_typing
- ***If it quacks like a duck and walks like a duck - it's a duck.**
- ```python
  class Duck:
	  def speak(self):
		  print("Quack!")

  class Car:
	  def speak(self):
		  print("Honk!")
		  
  animals = [Duck(), Car()]
  
  for animal in animals:
	  animal.speak()
  ```
- Działa jak polimorfizm, ale trochę uproszczony, czyli niezależnie od dziedziczenia i "pochodzenia" klasy - jeśli metody w klasach są te same, to można je grupować.

## Czym jest i jak używać aggregation?
#aggregation
- **aggregation** - relacja, gdzie jeden obiekt (jako całość) zawiera odniesienia do jednego lub większej liczby innych, niezależnych obiektów (jako części)
	- relacja typu **has-a**
		- czyli jak wynajmowanie czegoś
- ```python
  class Library:
	  def __init__(self, name):
		  self.name = name
		  self.books = []
		  
	  def add_book(self, book):
	  # dodawanie części elementów, które należą do klasy Books
		  self.books.append(book)
		  
	  def list_books(self):
	  # wyświetlanie elementów na podstawie atrybutów innej klasy
		  for book in self.books:
			  print(f"{book.name}, by {book.author}")
  class Book:
	  def __init__(self, title, author):
		  self.title = title
		  self.author = author
		  
  library = Library("Wrocławska Biblioteka")
  
  book1 = Book("Wieża jaskółki", "Andrzej Sapkowski")
  book2 = Book("Pan Lodowego Ogrodu, tom 1", "Jarosław Grzędowicz")
  
  library.add_book(book1)
  library.add_book(book2)
  library.list_books()
  ```
	- powyższy przykład pokazuje **dwie, niezależne od siebie klasy** (czyli mogą istnieć bez siebie nawzajem), w których **jedna klasa wykorzystuje elementy innej klasy**

## Czym jest i jak używać composition?
#composition
- **composition** - relacja, gdzie obiekt korzysta z elementów innych obiektów, ale nie może funkcjonować bez tych obiektów
	- relacja typu **owns-a**
		- czyli jak bycie właścicielem
- ```python
  class Engine:
	  def __init__(self, horse_power):
		  self.horse_power = horse_power
  
  class Wheel:
	  def __init__(self, size):
		  self.size = size
		  
  class Car: # klasa nadrzędna, która potrzebuje klas podrzędnych żeby istnieć
	  def __init__(self, model, horse_power, size):
		  self.model = model
		  self.hp = Engine(horse_power) # to jest praktyczna realizacja composition
		  self.wheel_size = Wheel(size)
		  # oba powyższe (self.hp i self.wheel_size) NIE SĄ ATRUBUTAMI, TYLKO INSTANCJAMI!
		  
	  def print_info(self):
		  print(f"Model: {self.model}, HP: {self.hp.horse_power}, wheel size:{self.wheel_size.size})
  ```
	- konstruktor wymaga atrybutu `wheel_size` do której jest przypisany `size` z klasy `Wheel`, więc żeby mogła powstać klasa `Car`, potrzebne jest istnienie klasy `Wheel`; tak samo z `Engine`
		- `Wheel` i `Engine` mogą istnieć bez `Car`, ale w drugą stronę już to nie działa
	- `self.hp = Engine(horse_power)` - zadeklarowanie atrybutu z koniecznością użycia atrybutu z innej klasy
	- `self.hp.horse_power` - otrzymanie zawartości atrybutu
		- w tym przypadku `self.hp` to **instancja klasy Engine**, stąd konieczne podane argumentu tej instancji przy wywołaniu

## Czym jest i jak używać nested classes?
#nested_class
- **Nested class (zagnieżdżona klasa)** - klasa zdefiniowana wewnątrz innej klasy
	- wykorzystywane do grupowania klas powiązanych ze sobą
	- enkapsuluje dane, które nie są potrzebne poza zewnętrzną klasą
	- nazewnictwo jest łatwiejsze; mniejsze ryzyko konfliktu nazw
- ```python
  class Company:
	  class Employee: # nested class
		  def __init__(self, name, position):
			  self.name = name
			  self.position = position
			  
		  def get_details(self):
			  print(f"{self.name} - {self.position}")
			  
	  def __init__(self, company_name):
		  self.company_name = company_name
		  self.employees = []
		  
	  def add_employee(self, name, position):
		  self.employees.append(self.Employee(name, position))
		  # tak korzysta się z atrybutów wew. klasy
		  
	  def list_employees(self):
		  for employee in self.employees:
			  employee.get_details()
		  
  company = Company("Carefleet")
  
  company.add_employee("Adrian", "Specjalista")
  
  company.list_employees()
  ```
	- w powyższy sposób korzysta się z nested classes
	- `self.Employee(atrybuty)` - służy do odwołania się do zagnieżdżonej klasy

## Czym jest i jak używać static methods?
#static_method
- **Static method** to metoda, która należy do klasy, a nie do danej instancji/obiektu
	- **nadają się do metod ogólnego użytku, bez potrzeby dostępu do danych klasowych**
- ```python
  class Employee:
	  def __init__(self, name, position):
		  self.name = name
		  self.position = position
		  
	  def get_details(self):
		  print(f"{self.name} - {self.position}")
		  
	  @staticmethod # deklaracja statycznej metody
	  def is_position_valid():
	  # tutej bez self, bo nie odnoszę się do żadnej instancji
		  valid_positions = ["Manager", "Janitor", "Specialist"]
		  return position in valid_positions
		  
  print(Employee.is_position_valid("Manager")) # True
  print(Employee.is_position_valid("CFO")) # False
  # w taki sposób wywołuje się static method
  ```

## Czym jest i jak używać class methods?
#class_method
- **Class method** pozwala na wykonywanie operacji na danych bezpośrednio związanych z daną klasą (np. class variables)
	- **nadają się do metod korzystających z danych klasowych albo z samej klasy**
	- ```python
	  average = 7.5
	  
	  @classmethod
	  def get_average(cls): # cls jest analogiczny do self
		  return f"Average smth: {cls.average}" # użycie podobnie do self
	  ```
	- tak wygląda składnia przy korzystaniu z class methods
- ```python
  class Student:
	  count = 0
	  avg_gpa = 0
	  
	  def __init__(self, name, gpa):
		  self.name = name
		  self.gpa = gpa
		  Student.count += 1
		  Student.avg_gdp += gpa
		  
	  def get_details(self):
		  return f"{self.name} - gpa: {self.gpa}"
		  
	  @classmethod
	  def get_count(cls):
		  return f"Number of students: {cls.count}"
		  
	  @classmethod
	  def get_avg_gpa(cls):
		  return f"Average GPA of students: {cls.avg_gpa / cls.count}"
  ```

## Czym są i jak używać magic methods?
#magic_method
- **Magic methods**, inaczej **dunder methods (double under)**, np. \_\_init\_\_, \_\_str\_\_, \_\_eq\_\_
	- są wywoływane automatycznie przez operacje wbudowane w Python
	- pozwalają na zdefiniowanie lub customizację zachowań obiektów
- ```python
  class Book:
	  def __init__(self, title, author, num_pages):
		  self.title = title
		  self.author = author
		  self.num_pages = num_pages
  ...
  # tutaj znajdują się magic methods z kolejnych punktów
  ...
  
  book1 = Book("Ostatnie Życzenie", "Andrzej Sapkowski", 320)
  book2 = Book("Pan Lodowego Ogrodu, tom 1", "Jarosław Grzędowicz", 490)
  ```
- **\_\_str\_\_** - string:
  ```python
  ...
	  def __str__(self):
		  return f"title: {self.title}, author: {self.author}"
  
  print(book1) # zwróci stringa z dundera __str__
  ...
  ```
	- czyli dunder \_\_str\_\_ sprawia, że użycie print() na obiekcie spowoduje zachowanie zgodne z tym, co jest zadeklarowane w odpowiednim dunderze
- **\_\_eq\_\_** - equal:
  ```python
  ...
	  def __eg__(self, other): # equal
		  return self.title == other.title and self.author == other.author
  
  print(book1 == book2) # True lub False
  ...
  ```
- **\_\_lt\_\_** - less than:
  ```python
  ...
	  def __lt__(self, other): # less than
		  return self.num_pages < other.num_pages
  
  print(book1 < book2) # True lub False
  ...
  ```
- **\_\_gt\_\_** - greater than:
  ```python
  ...
	  def __gt__(self, other): # greater than
		  return self.num_pages > other.num_pages
  
  print(book1 > book2) # True lub False
  ...
  ```
- **\_\_add\_\_** - add:
  ```python
  ...
	  def __add__(self, other): # add, dodawanie
		  return f"Total number of pages: {self.num_pages + other.num_pages}"
  
  print(book1 + book2) # suma liczby stron obu książek
  ...
  ```
- **\_\_contains\_\_** - contains:
  ```python
  ...
	  def __contains__(self, keyword): # contains, czy zawiera
		  return keyword in self.title or keyword in self.author
  
  print("Wiedźmin" in book1) # True lub False
  ...
  ```
- **\_\_getitem\_\_** - getitem:
  ```python
  ...
	  def __getitem__(self, key): # getitem
		  if key == "title":
			  return self.title
		  elif key == "author":
			  return self.author
		  elif key == "num_pages":
			  return self.num_pages
		  else:
			  return f"Key '{key}' was not found"
  
  print(book1["title"]) # tytuł obiektu
  ...
  ```
  
## Czym jest i jak używać property decorator?
#property_decorator #\@property
- **`@property`** - dekorator, którego używa się do zdefiniowania metody jako atrybutu (można access'ować go jak atrybut)
	- umożliwia dodanie dodatkowej logiki do read, write albo delete atrybutów
	- udostępnia metody **getter**, **setter** i **deleter**
- **`getter` + przykład `@property`**:
- ```python
  class Rectangle:
	  def __init__(self, width, height):
		  self._width = width
		  self._height = height
		  # _width i _height oznaczają że ten atrybut powinien być prywatny
		  # powinno się go używać jedynie w logice klasy, a nie wywoływać
		  # poza tą logiką
		  
	  @property
	  def width(self):
		  print(f"{self._width}cm")
		  
	  @property
	  def height(self):
		  print(f"{self._height}cm")
	  # powyższe można wywoływać jak atrybuty, a są metodami
	  
  rectangle = Rectangle(3, 5)
  
  rectangle.width
  rectangle.height
  # tutaj nastąpi wyświetlenie/otrzymanie atrybutów obiektów poprzez wywołanie metod pod setter
  ```
	- czyli "otrzymanie" (ang. get) danych
- **`setter`**:
- ```python
  class Rectangle:
	  def __init__(self, width, height):
		  self._width = width
		  self._height = height
		  
	  @property
	  def width(self):
		  print(f"{self._width}cm")
		  
	  @property
	  def height(self):
		  print(f"{self._height}cm")
		  
	  @width.setter # definiowanie zachowania setter
	  def width(self, new_width):
		  if new_width > 0:
			  self._width = new_width
		  else:
			  print("Width must be greater than 0")
			  
	  @height.setter # definiowanie zachowania setter
	  def height(self, new_height):
		  if new_height > 0:
			  self._height = new_height
		  else:
			  print("Height must be greater than 0")
			  
  rectangle = Rectangle(3, 5)
  
  rectangle.width = 4
  rectangle.height = 10
  # tutaj nastąpią podmiany atrybutów obiektów poprzez wywołanie metod pod setter
  ```
	- czyli zmiana wartości atrybutu
- **`deleter`**:
- ```python
  class Rectangle:
	  def __init__(self, width, height):
		  self._width = width
		  self._height = height
		  
	  @property
	  def width(self):
		  print(f"{self._width}cm")
		  
	  @property
	  def height(self):
		  print(f"{self._height}cm")
		  
	  @width.deleter # definiowanie zachowania deleter
	  def width(self):
		  del self._width
		  print("Width has been deleted")
			  
	  @height.deleter # definiowanie zachowania deleter
	  def height(self):
		  del self._height
		  print("Height has been deleted")
			  
  rectangle = Rectangle(3, 5)
  
  del rectangle.width
  del rectangle.height
  # tutaj nastąpi usunięcie atrybutów obiektów poprzez wywołanie metod pod delter
  ```
	- czyli usunięcie atrybutów

[Python docs](https://docs.python.org/3/tutorial/introduction.html)