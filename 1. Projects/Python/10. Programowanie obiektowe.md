#object_oriented_programming #oop
## Czym jest programowanie obiektowe?
#object_oriented_programming 
- W Python **wszystko jest obiektem**.
- **Programowanie obiektowe** to sposób myślenia o kodzie.
- Opiera się na **obiektach**, które łączą dane (**atrybuty**) i logikę/funkcje (**metody**)
	- Uporządkowuje to kod
	- Ułatwia zrozumienie kodu

## Jak utworzyć klasę i obiekt?
#class #object
```python
class User: # klasa
	def __init__(self, name, age): # konstruktor
		self.name = name
		self.age = age
	
	def print_info(self): # metoda
		print(self.name)
		print(self.age)
	
	def is_male(self): # metoda
		print(self.name[-1:] != 'a') # True lub False
		
person = User('Adrian', 25) # instancja

person.print_info() #wywołanie metody dla obiektu person
```
- **class *Nazwa*:**
	- klasa, czyli przepis na podstawie którego można utworzyć instancję, czyli obiekt
- **def __init__(self):**
	- **konstruktor**, który ustala początkowy stan dla obiektu
	- jeśli ma podane parametry, to do utworzenia instancji wymagane będzie podanie atrybutów
- **atrybut**
	- zmienna należąca do obiektu
- **metoda**
	- funkcja należąca do obiektu
	- zawsze jako pierwszy argument ma self
- **self**
	- odwołanie do konkretnej instancji, czyli:
		- ```python
		def print_info(self): # metoda
			print(self.name)
			print(self.age)
		
		person.print_info()
		```
		- **self** oznacza, że odnieś się w tej funkcji do danych z instancji **person**
- **instancja**
	- utworzenie obiektu na podstawie podanej klasy
- **wywołanie**
	- np. użycie metody `person.print_info()**`

## Jak importować dane z innego pliku?
#import
- **`from *nazwa_pliku* import *nazwa_klasy*`**
	- ten wpis dodaję na początku pliku w którym potrzebuję danych z innego pliku
	- mogę wyrzucić class do innego pliku i je importować, jeśli są potrzebne w różnych miejscach

## Czym są i jak korzystać z class variables?
#class_variables
- ```python
  class Car:
	  author = "Adrian W."
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
	  
	  def about_author(self):
		  print(f"Author is: {self.author}") # użycie class variable do metody
	
  car1 = Car("Cruze", 2010)
  
  print(car1.author) # tak raczej nie robić
  print(Car.author) # tak robić; wyjaśnienie niżej
  ```
	- każdy utworzony obiekt (instancja) ma dostęp do zmiennej `author`, która jest wspólna dla wszystkich obiektów
	- tworzone są **poza konstruktorem**
	- jak chcemy wyświetlić albo skorzystać z class variable, to raczej odnosimy się do niej przez klasę (`Car.author`)  niż przez obiekt (`car1.author`)
		- dobierając się do zmiennej przez car1, gdybym nie widział struktury klasy Car, to nie mógłbym rozróżnić czy jest to atrybut czy zmienna klasowa
		- korzystanie z takiej formy: `Car.author` jest dobrą praktyką i jest dużo bardziej czytelne
- ```python
  class Car:
	  num_cars = 0
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
		  Car.num_cars += 1
		  ...
	  ...
  ```
	- przy każdym utworzeniu nowego obiektu zwiększa się "licznik" liczby obiektów
	- wew. klasy też trzeba odnosić się w tej sposób: `Car.num_cars`, inaczej nie będzie to działało

## Jak działa dziedziczenie?
#inheritance
- **Dziedziczenie** polega na przekazaniu do klasy-dziecka atrybutów i metod klasy-rodzica.
	- zapewnia większe możliwości ponownego użycia klas i obiektów
- ```python
  class Animal:
	  def __init__(self, name):
		  self.name = name
		  self.is_alive = True
		  
	  def sleep(self):
		  print(f"{self.name} is sleeping")
		  
  class Dog(Animal): # inheritance
	  pass
	  
  class Cat(Animal): # inheritance
	  def speak(self): # metoda dostępna tylko dla obiektu klasy Cat
		  print("MEOW!")
	
  dog = Dog("Scooby")
  cat = Cat("Tom")
  ```
	- `class Klasa_dziecko(Klasa_rodzic):`
		- `def dodatkowe_metody_lub_atrybuty_klasy_dziecka()`
		- taka jest składnia dziedziczenia

## Jak działa wielokrotne dziedziczenie?
#multiple_inheritance #multilevel_inheritance
- **Multiple** - dziedziczenie od 2 lub większej liczby rodziców:
	- ```python
	  class Prey:
		  def flee(self):
			  print("This animal is running away")
	  
	  class Predator:
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Prey, Predator): # multiple inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.flee()
	  fish.hunt() # obie metody zadziałają
			  
	  ```
- **Multilevel** - dziedziczenie od rodzica, który już dziedziczy coś od rodzica
	- ```python
	  class Animal:
		  def eat(self):
			  print("This animal is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print("This animal is hunting")
			  
	  class Fish(Predator): # multilevel inheritance
		  pass
		  
	  fish = Fish()
	  
	  fish.eat()
	  fish.hunt() # obie metody zadziałają
	  ```
- **Dziedziczenie atrybutów**:
	- ```python
	  class Animal:
		  def eat(self):
			  print(f"{self.name} is eating")
			  
	  class Predator(Animal):
		  def hunt(self):
			  print(f"{self.name} is hunting")
			  
	  class Fish(Predator):
		  def __init__(self, name):
			  self.name = name
		  
	  fish = Fish("Rypka")
	  
	  fish.eat()
	  fish.hunt()
	  ```
	- nie ma znaczenia na którym poziomie zostanie zdefiniowany konstruktor, najważniejsze żeby się nie powtarzały w ramach dziedziczonych klas

## Czym są klasy abstrakcyjne i jak się ich używa?
#abstract_class
- **Abstract class** - jest klasą, która **nie jest** przeznaczona do bezpośredniego tworzenia obiektów
	- służy np. jako interfejs dla grupy klas
	- można wymusić, żeby każda klasa potomna miała pewne metody, ale jednocześnie te potomne klasy mają swobodę w implementacji tych metod

- `from abc import ABC, abstractmethod`
	- `abc` - abstract base **classes**
	- `ABC` - abstract base **class**
- **ABC (Abstract Base Class)** - to tylko baza, która umożliwia stworzenie klasy abstrakcyjnej. Do stworzenia prawdziwej klasy abstrakcyjnej potrzebne jest zdefiniowanie dla takiej klasy **@abstractmethod**
- **@abstractmethod** - definiuje metodę klasy abstrakcyjnej:
	- można zdefiniować działanie metody w ciele klasy abstrakcyjnej
	- można wymusić konieczność zdefiniowania metody na klasie, która będzie dziedziczyła po klasie abstraktyjnej:
		- ```python
		  class Shape(ABC):
			  @abstractmethod
			  def area(self):
				  pass
				  
		  class Square(Shape):
			  def __init__(self, length):
				  self.length = length
				  
			  def area(self):
				  print(f"Square area: {self.length ** 2}")
		  ```






[Python docs](https://docs.python.org/3/tutorial/introduction.html)
[Python OOP](https://www.youtube.com/watch?v=IbMDCwVm63M) <- tu wrócić