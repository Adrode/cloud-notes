#object_oriented_programming #oop
## Czym jest programowanie obiektowe?
#object_oriented_programming 
- W Python **wszystko jest obiektem**.
- **Programowanie obiektowe** to sposób myślenia o kodzie.
- Opiera się na **obiektach**, które łączą dane (**atrybuty**) i logikę/funkcje (**metody**)
	- Uporządkowuje to kod
	- Ułatwia zrozumienie kodu

## Jak utworzyć klasę i obiekt?
#class #object
```python
class User: # klasa
	def __init__(self, name, age): # konstruktor
		self.name = name
		self.age = age
	
	def print_info(self): # metoda
		print(self.name)
		print(self.age)
	
	def is_male(self): # metoda
		print(self.name[-1:] != 'a') # True lub False
		
person = User('Adrian', 25) # instancja

person.print_info() #wywołanie metody dla obiektu person
```
- **class *Nazwa*:**
	- klasa, czyli przepis na podstawie którego można utworzyć instancję, czyli obiekt
- **def __init__(self):**
	- **konstruktor**, który ustala początkowy stan dla obiektu
	- jeśli ma podane parametry, to do utworzenia instancji wymagane będzie podanie atrybutów
- **atrybut**
	- zmienna należąca do obiektu
- **metoda**
	- funkcja należąca do obiektu
	- zawsze jako pierwszy argument ma self
- **self**
	- odwołanie do konkretnej instancji, czyli:
		- ```python
		def print_info(self): # metoda
			print(self.name)
			print(self.age)
		
		person.print_info()
		```
		- **self** oznacza, że odnieś się w tej funkcji do danych z instancji **person**
- **instancja**
	- utworzenie obiektu na podstawie podanej klasy
- **wywołanie**
	- np. użycie metody `person.print_info()**`

## Jak importować dane z innego pliku?
#import
- **`from *nazwa_pliku* import *nazwa_klasy*`**
	- ten wpis dodaję na początku pliku w którym potrzebuję danych z innego pliku
	- mogę wyrzucić class do innego pliku i je importować, jeśli są potrzebne w różnych miejscach

## Czym są i jak korzystać z class variables?
#class_variables
- ```python
  class Car:
	  author = "Adrian W."
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
	  
	  def about_author(self):
		  print(f"Author is: {self.author}") # użycie class variable do metody
	
  car1 = Car("Cruze", 2010)
  
  print(car1.author) # tak raczej nie robić
  print(Car.author) # tak robić; wyjaśnienie niżej
  ```
	- każdy utworzony obiekt (instancja) ma dostęp do zmiennej `author`, która jest wspólna dla wszystkich obiektów
	- tworzone są **poza konstruktorem**
	- jak chcemy wyświetlić albo skorzystać z class variable, to raczej odnosimy się do niej przez klasę (`Car.author`)  niż przez obiekt (`car1.author`)
		- dobierając się do zmiennej przez car1, gdybym nie widział struktury klasy Car, to nie mógłbym rozróżnić czy jest to atrybut czy zmienna klasowa
		- korzystanie z takiej formy: `Car.author` jest dobrą praktyką i jest dużo bardziej czytelne
- ```python
  class Car:
	  num_cars = 0
	  
	  def __init__(self, model, year):
		  self.model = model
		  self.year = year
		  Car.num_cars += 1
		  ...
	  ...
  ```
	- przy każdym utworzeniu nowego obiektu zwiększa się "licznik" liczby obiektów
	- wew. klasy też trzeba odnosić się w tej sposób: `Car.num_cars`, inaczej nie będzie to działało


[Python docs](https://docs.python.org/3/tutorial/introduction.html)
[Python OOP](https://www.youtube.com/watch?v=IbMDCwVm63M) <- tu wrócić