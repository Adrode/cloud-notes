#sqlalchemy
## Czym jest SQLAlchemy?
#sqlalchemy 
- **SQLAlchemy** - składa się z toolkita SQL do Pythona (sqlalchemy core) oraz z ORM (Object Relational Mapper).
	- ORM czyli obsługa SQL z poziomu Pythona, za pomocą obiektów, gdzie klasy reprezentują tablice
	- przykładowy kod
```python
from sqlalchemy import create_engine, Integer, String, Float, Column, ForeignKey
from sqlalchemy.orm import declarative_base, sessionmaker, relationship

engine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/satutorialdatabase', echo=True)

Base = declarative_base()

class Person(Base):
	__tablename__ = 'people'
	id = Column(Integer, primary_key=True)
	name = Column(String, nullable=False)
	age = Column(Integer)
	
	things = relationship('Thing', back_populates='person')
	
class Thing(Base):
	__tablename__ = 'things'
	id = Column(Integer, primary_key=True)
	description = Column(String, nullable=False)
	value = Column(Float)
	owner = Column(Integer, ForeignKey('people.id'))
```

## Jak zainstalować SQLAlchemy?
#sqlalchemy 
- Instalacja za pomocą pip:
	- `pip install sqlalchemy`

## Jakie są podstawy SQLAlchemy Core?
#sqlalchemy #core #sqlite
- **SQLite** - to plik i biblioteka
	- plik `.db` przechowuje bazę danych (tabele, constrainty, relacje, itd.)
	- biblioteka `SQLite` obsługuje bazę (czyta i zapisuje dane, parsuje i wykonuje SQL, zarządza transakcjami)
		- `sqlite3 nazwa_bazy.db` - w ten sposób można wejść do powłoki (terminal) biblioteki sqlite
```python
from sqlalchemy import create_engine, text

engine = create_engine('sqlite:///mydatabase.db', echo=True)
...
```
- `engine` - tworzy centralny obiekt SQLAlchemy (przez `create-engine`), czyli:
	- trzyma informacje jak połączyć się z bazą
	- zarządza połączeniem z bazą danych
	- wysyła SQL do bazy
- `sqlite:///mydatabase.db` - URL bazy danych:
	- `sqlite` - typ bazy danych
	- `:///` - lokalny plik
	- `mydatabase.db` - plik bazy danych
- `echo=True` - wyświetla generowane zapytania SQL do konsoli
	- bardzo przydatne do debugowania i nauki
```python
...
conn = engine.connect()

conn.execute(text("CREATE TABLE IF NOT EXISTS people (name str, age int)"))

conn.commit()
```
- `engine.connect()` - nawiązanie połączenia między Pythonem a bazą danych
- `conn.execute(text(SQL query))` - wykonanie zapytania SQL
	- jednocześnie ten .execute() otwiera transakcję
- `conn.commit()` - zamknięcie transakcji, zapisanie zmian

```python
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String

engine = create_engine('sqlite:///mydatabase.db', echo=True)

meta = MetaData()

people = Table(
	"people",
	meta,
	Column('id', Integer, primary_key=True),
	Column('name', String, nullable=False),
	Column('age', Integer)
)

meta.create_all(engine)
...
```
- `meta = MetaData()` - `meta` jest obiektem, który przechowuje opis struktury bazy danych
	- jakie są tabele, kolumny, typy danych, primary keys i foreign keys, constraints, itd.
	- w powyższym przypadku `people` to definicja tabeli, a `meta` przechowuje dane na temat tej tabeli (oraz innych, jeśli inne tabele by istniały)
- `meta.create_all(engine)` - na podstawie informacji o tablicach w `meta` tworzy requesty do bazy danych, które utworzą te tabele
### Insert
#insert
```python
...
conn = engine.connect()

insert_statement = people.insert().values(name='Adrian', age=26)
result = conn.execute(insert_statement)

conn.commit()
```
- `table_name.insert().values(...)` - insert danych do tabeli
	- `conn.execute(^powyższa_komenda)` - wykonanie inserta zapisanego wcześniej do zmiennej
### Select
#select
```python
...
conn = engine.connect()

select_statement = people.select()
result = conn.execute(select_statement)

for row in result.fetchall():
	print(row)
	# ten sposób wyświetli wszystkie wiersze w formie krotek
```
- `table_name.select()` - prosty select, który wyciągnie wszystkie dane
	- `.select().where(table_name.c.age > 20)` - WHERE z SQLa;
		- `table_name.c` - konieczne jest to `.c`, odnosi się do kolumn tego obiektu
- `.fetchall()` - pobiera wszystkie wiersze z wyniku zapytania i zapisuje je do pamięci w formie listy
	- `.fetchone()` - pobiera jeden wiersz
	- `.scalar()` - pobiera jedną wartość (np. COUNT)
	- `.one()` - dokładnie jeden wiersz albo błąd
### Update
#update
```python
...
conn = engine.connect()

update_statement = people.update().where(people.c.name = 'Adrian').values(age = 25)
result = conn.execute(update_statement)

conn.commit()
```
- `table_name.update().where(table_name.c.name = 'A').values(table_name.c.age = 1)` -schemat UPDATE'a
### Delete
#delete
```python
...
conn = engine.connect()

delete_statement = people.delete().where(people.c.id = 1)
result = conn.execute(delete_statement)

conn.commit()
```
- `table_name.delete().where(table_name.c.id = 1)` - schemat DELETE'a

## Jak utworzyć i obsłużyć relationship?
#relationship #foreign_key 
```python
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, ForeignKey

engine = create_engine('sqlite:///mydatabase.db', echo=True)

meta = MetaData()

people = Table(
	"people",
	meta,
	Column('id', Integer, primary_key=True),
	Column('name', String, nullable=False),
	Column('age', Integer)
)

things = Table(
	"things",
	meta,
	Column('id', Integer, primary_key=True),
	Column('description', String, nullable=False),
	Column('owner', Integer, ForeignKey('people.id')) # utworzenie relacji, FK
)

meta.create_all(engine)
```
- `Column('owner', Integer, ForeignKey('people.id'))` - poprzez ForeignKey tworzy się relację
	- tutaj jest to relacje 1:N
	- przy N:N oczywiście trzeba by stworzyć association table
### Join 
#join
- Zakładam że mam relację 1:N, jak w powyższym przykładzie relacji tabel people - things
```python
conn = engine.connect()

join_statement = people.join(things, people.c.id == things.c.owner)
select_statement = people.select().with_only_columns(people.c.name, things.c.description).select_from(join_statement)

result = conn.execute(select_statement)

for row in result.fetchall():
	print(row)
	
conn.commit()
```
- przykład joinów w SQLAlchemy
- przy relacji N:N analogicznie, tylko robi się dalszy ciąg joina, tak jak w SQL
- można użyć **innych rodzajów join'ów**:
	- **`.outerjoin()`** - wyświetli wszystkie wiersze z łączonych tabel, a tak gdzie nie ma relacji da drugą wartość jako None
	- 

https://www.youtube.com/watch?v=529LYDgRTgQ
35:25

## Jaki jest schemat łączenia się z bazą danych?
#create_engine
- **`engine = create_engine('postgresql+psycopg2://USER:PASSWORD@HOST:PORT/DB_NAME')`**
	- jeśli PostgreSQL jest wystawiony na kontenerze Dockera, to po powyższym schemacie można się połączyć
	- `pip install psycopg2-binary` - potrzebne, `psycopg2` służy do łączenia Postgresa z Pythonem




- **Session** w ORM:
```python
from sqlalchemy.orm import Session

engine = create_engine('sqlite:///mydatabase.db', echo=True)
session = Session(engine)

session.execute(text('INSERT INTO people (name, age) VALUES ("Mike", 30);'))

session.commit()
```