#fastapi
## Czym jest FastAPI?
#fastapi
- **FastAPI** to framework, który służy do tworzenia API w Python.
	- Charakteryzuje się szybką wydajnością i nowoczesnością.
	- Oparty jest na **Starlette** (wydajność) i **Pydantic** (walidacja danych).
	- Automatycznie generuje dokumentację w **Swagger**.

## Jak utworzyć projekt FastAPI?
#fastapi 
- Należy utworzyć wirtualne środowisko (`venv`), zainstalować na nim fast api (`pip install fastapi`), kolejno utworzyć plik np. `main.py`, w którym będzie skrypt i uruchomić ten skrypt na lokalnym serwerze poprzez komendę `uvicorn main:app --reload` lub `fastapi dev main.py`
	- tutaj `main` to nazwa skrypyu, a `app` to nazwa instancji FastAPI w tym skrypcie (`app = FastAPI()`)
	- pojawią się adresy IP pod którymi można zobaczyć działanie skryptu lub dokumentację

## Jak wygląda przykładowy kod?
#fastapi 
- ```python
from fastapi import FastAPI

app = FastAPI() # app to instancja klasy FastAPI

all_todos = [
  {'id': 1, 'category': 'sports', 'description': 'Go to the gym'},
  {'id': 2, 'category': 'programming', 'description': 'Learn for 2h'},
  {'id': 3, 'category': 'reading', 'description': 'Read a book for 15 minutes'},
  {'id': 4, 'category': 'meditating', 'description': 'Meditate for 10 minutes'},
  {'id': 5, 'category': 'food', 'description': 'Eat 2700 kcal'},
  {'id': 6, 'category': 'sports', 'description': 'Run for 30 minutes'},
  {'id': 7, 'category': 'food', 'description': 'Prepare recipes'},
  {'id': 8, 'category': 'programming', 'description': 'Prepare a project'},
]
# przykładowe dane

@app.get("/todos/all") # @app.get to method decorator
def get_all_todos():
  return all_todos
# przykładowe obsłużenie żądania
  ```
  - dzięki powyższemu pod URL: `localhost_ip/todos/all` zostaną wyświetlone wszystkie elementy danych
  - logika: np. w przeglądarce pojawia sie URL, jeśli program dopasuje URL do któregoś z `@app.get` to wykonuje jego funkcję
  - funkcja zwraca JSON

## Jak działają path i query parameters?
#query_parameters #path_parameters
- Path parameters:
	- ```python
# path parameters
@app.get("/todos/{id}") # tuaj id to path parameter
def get_todo(id: int): # należy podać typ danych
  for item in all_todos:
    if item['id'] == id:
      return {'result': item}
	  ```
	- są częścią ścieżki, oddzielone `/`, np. `GET /todos/1`
	- **służą do indentyfikacji konkretnego zasobu**
- Query parameters:
	- ```python
# query parameters
@app.get("/todos/filter")
# w odróżnieniu od path params, tutaj nie podaje się query params
def get_category(category: str): # należy podać typ danych
# parametr podany w funkcji zostanie automatycznie zamieniony na query param w URL
  results = []
  for item in all_todos:
    if item['category'] == category:
      results.append(item)
  return results
	  ```
	- są po znaku `?` i są parą `klucz=wartość`, oddzielone `&`, np. `GET /todos/filter?category=programming`
	- **służą najczęściej do filtrowania, sortowania lub stronicowania kolekcji zasobów**

## Jak działa i jak używać Enum w ramach FastAPI?
#enum
- ```python
from fastapi import FastAPI
from enum import Enum

app = FastAPI()

class CategoryEnum(str, Enum):
  sports = "sports"
  programming = "programming"
  reading = "reading"
  meditating = "meditating"
  food = "food"
  
@app.get("/todos/by-category/{category}")
def get_category(category: CategoryEnum):
  return [item for item in all_todos if item['category'] == category.value] # .value wyciąga strng z Enum
  ```
	- nadanie **`CategoryEnum`** jako typ dla path parameter sprawia, że jedyne możliwe wartości dla tego pola to te, które są zdefiniowane w ramach Enum
	- w Swagger do wyboru pojawią się na liście tylko zdefiniowane w Enum wartości, nic innego nie można tam wpisać

## Jak działa i jak używać Pydantic (BaseModel)?
#pydantic #basemodel
- ```python
from fastapi import FastAPI
from pydantic import BaseModel

class TaskCreate(BaseModel):
  title: str
  description: str
  priority: TaskPriority
  status: TaskStatus = TaskStatus.todo

class Task(BaseModel):
  id: int
  title: str
  description: str
  priority: TaskPriority
  status: TaskStatus
  created_at: str
  
class UpdateStatus(BaseModel):
  status: TaskStatus
  priority: TaskPriority
  
@api.post("/tasks/create")
def tasks_post(task: TaskCreate):
  task_id = max(item['id'] for item in tasks) + 1 if tasks else 1

  new_task = {
    'id': task_id,
    'title': task.title,
    'description': task.description,
    'priority': task.priority,
    'status': task.status,
    'created_at': str(datetime.datetime.now())
  }

  tasks.append(new_task)
  return new_task
  
@api.put("/tasks/{id}/status")
def put_status(id: int, update: UpdateStatus):
  for item in tasks:
    if item['id'] == id:
      item['status'] = update.status
      return item
  
@api.get("/tasks")
def get_tasks(status: TaskStatus | None = None, priority: TaskPriority | None = None, skip: int = 0, limit: int = 10):
  filtered = tasks
  if status:
    filtered = [item for item in filtered if item['status'] == status.value]
  if priority:
    filtered = [item for item in filtered if item['priority'] == priority.value]

  return filtered[skip:skip+limit]
  ```
	- Pydantic służy do walidacji danych poprzez określenie typu danych
		- definiuje się go poprzez klasę która dziedziczy po BaseModel (wcześniej trzeba zaimportować)
	- jeśli dany typ danych zostanie określony jako np. Enum, to będą dostępne tylko wartości z Enum
## Jak używać Query i Annotated?
#query #annotated
- **Annotated** - standardowo służy do nadania metadanych w Python; w FastAPI jest wykorzystywane do określenia typu i walidacji danych (przez Query)
- **Query** - służy do walidacji query paramteres
- ```python
from fastapi import FastAPI, Query
from typing import Annotated

@api.get("/tasks/search")
def get_search(
  text: Annotated[str, Query(min_length=3)],
  #               ^typ, ^metadane (tutaj Query służy do walidacji)
  title: Annotated[str | None, Query(description="Search by title")] = None
):
  filtered = [item for item in tasks if item['title'] == title] if title else tasks
  searched = [item for item in filtered if text.lower() in item['description'].lower()]
  return searched
  ```

## Jak obsługiwać wyjątki HTTP?
#httpexception
- Wyjątki obsługuje się za pomocą **HTTPException**:
- ```python
from fastapi import FastAPI, HTTPException
  
api = FastAPI()
  
products = []
  
@api.get("/products/{id}")
def get_product(id: int):
	for item in products:
		if item["id"] == id:
			return item
	raise HTTPException(
		status_code=404,
		detail=f"Product with id: {id} not found",
		headers={"X-Error": "There goes my error"} # opcjonalny header
	)
  ```
	- w przypadku braku elementu o wskazanym id w liście, zostanie obsłużony błąd od statusu 404, z wiadomością `{"detail": "Product with id: ... not found"}`

## Jak stworzyć custom exception handler?
#exception_handler
- ```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
  
class NotFoundException(Exception): # koniecznie dziedziczenie po Exception
  def __init__(self, id):
	  self.id = id
	  
api = FastAPI()

products = []

@api.exception_handler(NotFoundException):
def id_not_found_exception_handler(request: Request, exception: NotFoundException):
# handler musi przyjąć oba argumenty, request i exception
	return JSONResponse(
		status_code=404,
		headers={"X-Error": "ID-Not-Found"},
		content={"detail": f"Id {exception.id} not found"}
	)
	
@api.get("/products/{id})
def get_product(id: int):
	for item in products:
		if item["id"] == id:
			return item
	raise NotFoundException(id=id)
  ```
	- jest to bardziej uniwersalny sposób, dzięki któremu można obsłużyć błędy dla różnych statusów, bez powtarzania kody HTTPException