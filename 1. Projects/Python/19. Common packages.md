#packages 

## Jak korzystać z requests?
#requests
- **requests** - paczka, która umożliwia komunikowanie się z HTTP (API)
	- nie wystarczy import, trzeba ją wcześniej zainstalować
		- `pip install requests`
	- ```python
import requests # import modułu requests

base_url = "https://pokeapi.co/api/v2/"

def get_pokemon_info(name):
  url = f"{base_url}pokemon/{name}"
  response = requests.get(url)
  
  if response.status_code == 200:
    pokemon_data = response.json() # pobranie z body zawartości JSON
    return pokemon_data
  else:
    print(f"Failed to retireve data - {response.status_code}")

pokemon_name = "pikachu"
pokemon_info = get_pokemon_info(pokemon_name)

if pokemon_info:
  print(f"Name: {pokemon_info["name"]}")
  print(f"Height: {pokemon_info["height"]}")
  print(f"Abilities: {[item["ability"]["name"] for item in pokemon_info["abilities"]]}")
	  ```
	- `requests.get(url)` - wysłanie żądania do API
		- zwraca obiekt Response, który ma właściwości np.:
			- `.text` - tekst body
			- `.json` - JSON body
			- `.status_code` - status odpowiedzi
			- `.headers` - nagłówki
			- `.content` - bajty body

## Jak przekazać parametry do URL w metodzie get?
#params
- Strona **httpbin.org** pozwala na testowania responses i requests.
	- Na niej można testować sobie poprawność przesyłanych paramterów
- **Parametry** - dodatkowe informacje zawarte w URL, dotyczące zawartości strony; parametry znajdują się po znaku **'?'**
	- `https://httpbin.org/get?page=2&count=25`
	- w Python można wpisać parametry bezpośrednio do URL, ale raczej robi się to w formie zdefiniowania **dict payload**:
	- ```python
import requests

payload = {'page': 2, 'count': 25}
response = requests.get("https://httpbin.org/get", params=payload)

print(response.url) # returns "https://httpbin.org/get?page=2&count=25"
	  ```

## Jak korzystać z metody post?
#post
- **`requests.post()`** - przekazuje dane do serwera HTTP
	- ```python
import requests

payload = {'username': 'Adrian', 'password': 'test'}
req = requests.post("https://httpbin.org/post", data=payload)
req_dict = req.json()

print(req_dict)
# returns
# {'args': {}, 'data': '', 'files': {}, 'form': {'password': 'test', 'username': 'Adrian'},
#  'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate, br', 'Content-Length': '29',
#              'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org',
#              'User-Agent': 'python-requests/2.31.0', 'X-Amzn-Trace-Id': 'Root=1-69208f55-278e6bd37c4534d7006c2bc8'},
#   'json': None, 'origin': '83.4.167.93', 'url': 'https://httpbin.org/post'}

print(req_dict['form'])
# returns
# {'password': 'test', 'username': 'Adrian'}
	  ```

## Jak przesyłać JSON w post?
#post #json
- ```python
  payload = {'name': 'Adrian', 'age': 25}
  
  response = requests.post(url, json=payload)
  ```
	- gdy chcemy przesłać JSON, używamy **json**, a nie **data**!
		- zapis `json=...` ustawia w nagłówku `Content-Type: application/json`

## Jak ustawić timeout dla wysyłanego requesta?
#timeout
- `response = requests.get(url/delay/5, timeout=3)`
	- w takim wypadku responsem będzie kod rzędu 400, ponieważ timeout nadejdzie szybciej niż wysłane żądanie
- `response = requests.get(url/delay/2, timeout=3)`
	- w takim wypadku response będzie rzędu 200, czyli ok

## Jak wysyłać nagłówki przez post?
#headers
- W **headers** można wysyłać np. token, typ treści, user-agent:
	- ```python
import requests

headers = {'X-Client': 'Adrian-Tester'}
response = requests.get("https://httpbin.org/get", headers=headers)

print(response.json()["headers"])
	  ```
	- ```python
import requests

headers = {"User-Agent": "Mozilla/5.0 (Linux; Android 10)"}
response = requests.get("https://httpbin.org/get", headers=headers, timeout=3)

print(response.text)
	  ```

## Jak obsługiwać wyjątki?
#try_except
- Obsługa wyjątków **try except** w przypadku pojawienia się błędów w odpowiedzi z serwera:
	- ```python
import requests

def fetch_url(url, timeout_sec):
  try:
    response = requests.get(url, timeout=timeout_sec)
  except requests.exceptions.Timeout:
    return "Timeout error"
  except requests.exceptions.RequestException:
    return f"{response.status_code} error"

  return response.json()

print(fetch_url("https://httpbin.org/delay/3", 1))
print(fetch_url("https://httpbin.org/delay/3", 5))
	  ```
	- ```python
import requests

def safe_url(url):
  try:
    response = requests.get(url, timeout=3)
  except requests.exceptions.ConnectionError:
    return "Connection error"
  except requests.exceptions.Timeout:
    return "Timeout error"
  except requests.exceptions.RequestException:
    return f"{response.status_code} error"
  if response.status_code == 404:
    return f"{response.status_code} not found"
  if response.status_code == 500:
    return f"{response.status_code} server error"
  
  return response.json()

print(safe_url("https://httpbin.org/status/404"))
print(safe_url("https://httpbin.org/status/500"))
print(safe_url("https://thisdomaindoesnotexist123123.com"))
	  ```
	- **`response.raise_for_status()`** - pozwala na łapanie wszystkich błędów HTTP jako exceptions
		- np. w powyższym kodzie zamiast obsługi `if response.status_code == 404`, itd., mógłbym w `try`, po `response` zrobić `response.raise_for_status()` i wtedy błędy 404, 500, itp. byłyby obsłużone w ramach wyjątku `RequestException`

## Jak pobierać zawartość do pliku?
#with 
- ```python
import requests

def fetch_img(url):
  try:
    headers = {
      "User-Agent": "Mozilla/5.0 (compatible; MyPythonScript/1.0)"
    }
    response = requests.get(url, timeout=3, headers=headers)
    response.raise_for_status()
    with open("output.png", 'wb') as f:
      f.write(response.content)
    
    return "OK"
  except requests.exceptions.Timeout:
    return "Timeout"
  except requests.exceptions.ConnectionError:
    return "Connection error"
  except requests.exceptions.RequestException as e:
    return e

print(fetch_img("https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png"))
  ```
	- przykładowy kod

## Jak i po co ustanowić sesję?
#session
- **Session** otwiera sesję (połączenie) i pozwala na zachowanie ustalonych parametrów w kolejnych żądaniach HTTP, np. cookies, headers, auth.
	- przykładowe ustanowienie sesji i nadanie nagłówka dla wszystkich żądań w sesji:
		- ```python
			import requests

			session = requests.Session()
			
			session.headers.update({"X-Session": "test123"})
			response = session.get("https://httpbingo.org/headers")
			
			print(response.json())
			
			session.close()
		  ```
	- Różnica w wysyłaniu cookies między session a zwykłym request:
		- ```python
			import requests

			session = requests.Session()
			session.get("https://httpbin.org/cookies/set?uzytkownik=Jan")
			# ^ wysłanie cookies (httpbin do wysłania używa get, a nie post)
			# normalnie na produkcji tutaj powinno być post
			response1 = session.get("https://httpbin.org/cookies")
			# ^ tutaj pobieram ustawione cookies
			print(response1.json())
			# ^ cookies się wyświetlą
			session.close()
			
			requests.get("https://httpbin.org/cookies/set?uzytkownik=Jan")
			# ^ wysyłam cookies
			response2 = requests.get("https://httpbin.org/cookies")
			# ^ pobieram cookies
			print(response2.json())
			# ^ pusty dict, bo nie zapisały się cookies, ponieważ nie są w jednej
			# sesji
		  ```
	- Ustawienie headers dla sesji:
		- ```python
			import requests
			
			session = requests.Session()
			session.headers.update({
				"User-Agent": "MojBot/1.0",
				"Accept-Language": "pl-PL"
			})
			# ^ ustawienie nagłóków
			response1 = session.get("https://httpbin.org/headers")
			print(response1.json())
			response2 = session.get("https://httpbin.org/headers")
			print(response2.json())
			response3 = session.get("https://httpbin.org/headers")
			print(response3.json())
			# każdy z powyższych będzie miał te same, ustawione wcześniej nagłówki
			
			session.close()
		  ```

## Jak ustawiać autoryzację w żądaniu?
#auth
- **Basic-Auth:**
	- ```python
	import requests
	
	response = requests.get("https://httpbin.org/basic-auth/user/passwd",                   auth=('user', 'passwd'))
	print(response.json())
	# poprawna autoryzacja
	
	response2 = requests.get("https://httpbin.org/basic-auth/user/passwd")
	print(response2.json())
	# błąd w autoryzacji, brak auth, 401
  ```
- **Bearer Token:**
	- ```python
	import requests
	
	token = "moj_super_sekretny_token_12345"
	headers = {'Authorization': f'Bearer {token}'}
	
	response = requests.get("https://httpbin.org/bearer", headers=headers)
	print(response.json())
	  ```
	- przekazywany w headers, jak klucz ('Authorization') i wartość ('Bearer *token*')
	- czym się różnią?
		- Basic-Auth wymaga ciągłej autoryzacji przy każdym request, nie wygasa, prostsze w użyciu, może być dobre do narzędzi wewnętrznych (np. dashboard)
		- Bearer Token dobrze działa w ramach sesji, po zalogowaniu user otrzymuje token, który zawiera w sobie wszystkie informacje (**TWJ**) i wygasa po określonym czasie (określone w "treści" tokena), jak się skończy to jest ponownie generowany
- **API Key:**
	- ```python
	import requests

	headers = {
	  'X-API-Key': '12345abcde'
	}
	response = requests.get("https://httpbin.org/headers", headers=headers)
	print(response.json())
	```
	- np. do korzystania z API Google Maps, OpenAI, Spotify, itp.
	- przekazywany jest w nagłówku

## Jak przesyłać pliki?
#files
- Przesyłanie przez post:
	- ```python
	import requests
	
	files = {'file': open('test2.txt', 'rb')}
	# pliki wrzucone do dict, zawartość pliku przechowana w formie binarnej 'rb'
	data = {'author': 'Adrian', 'description': 'Duckin Duck'}
	# dodatkowe informacje, niewymagane przy przesyłaniu plików
	response = requests.post("https://httpbin.org/post", files=files, data=data)
	# przesłanie pliku
	print(response.json())
	# w odpowiedzi, pod 'files' będzie treść pliku, pod 'form' treść data
	  ```