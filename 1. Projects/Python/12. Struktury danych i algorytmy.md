#data_structures #algorithms

## Czym są built in i user defined data structures?
#built_in #user_defined
- Przykłady **built in**:
	- list
	- tuple
	- set
	- dictionary
- Przykłady **user defined**:
	- stack
	- queue
	- linked list
	- tree
	- graph

## Czym różni się static array od dynamic array od strings?
#static_array #dynamic_array #strings
- W Python standardowo nie ma czegoś takiego jak static array z poziomu pisania kodu
- **Static array** - tablica, która nie zmienia swojej długości
	- mam 5 elementów, usuwam jeden to zostaje mi ta sama długość, tylko jedno miejsce mam niezagospodarowane
	- mam 5 elementów i dodać kolejny element to tworzy problem, bo mam stałą długość tablicy
- **Dynamic array** - w Python jest to list, która dynamicznie dostosowuje długość tablicy (listy)
- **Strings** - w Python strings są **niemutowalne**. Można dobrać się do zawartości po indexach, ale nie da się dodać / usunąć / zamienić znaku na początku / końcu / środku

## Jak działa stack?
#stack 
- **Stack** - stos; porównać można do ułożonych na półce talerzy:
	- jeśli mam 5 ponumerowanych talerzy, ułożonych jeden na drugim, to naturalną kolejnością wyciągania talerzy będzie nr. 5 > nr. 4 > nr. 3 > ... > nr. 1
		- czyli nie mogę dobrać się do talerza nr. 3, bez wcześniejszego dostępu do talerza nr. 4 i nr. 5 

## Jak użyć stack?
#stack 
- **Stack** to **user defined** data structure.
	- Można stacka używać jako list:
		- użycie na list **.append(*jakaś wartość*)**, doda po kolei wartości
		- kolejno użycie **.pop()** (bez podanego argumentu) usunie wartość z .pop zgodnie z zamysłem stack (czyli chronologicznie - od najświeższej do najstarszej)
		- ***list*\[-1]** również zwraca najświeższy element dodany do list

## Czym jest linked list?
#linked_list
- **Linked list** - struktura powiązanych węzłów, gdzie każdy węzeł przechowuje wartość i wskaźniki do kolejnego elementu
	- listy są **węzłami (node)**, są połączone w łańcuchem i każda lista wskazuje na kolejną listę
- **Singly Linked List**:
	- każdy węzeł wskazuje na kolejny węzeł i łańcuch się zakańcza w momencie gdy ostatni węzeł nie ma kolejnej listy do powiązania, więc jego next będzie None
	- początkowy węzeł to **Head**, a zakończenie to po prostu zwrócenie None
	- ```python
	  class SinglyNode:
		  def __init__(self, value, next_node=None):
			  self.value = value
			  self.next_node = next_node
			  
		  def __str__(self):
			  return str(self.value)
			  
		Head = SinglyNode(1)
		A = SinglyNode(4)
		B = SinglyNode(7)
		C = SinglyNode(11)
		# powyższe to powiązania list w LinkedList
	  ```
		- wyświetlenie węzłów:
			- ```python
			  def display(head):
				  current = head
				  while current:
				  # zakończone w momencie gdy węzeł ksaże None, czyli koniec łańcucha
					  print(current)
					  current = current.next
					  # "przełączenie" na kolejny element łańcucha
			  ```
		- wyszukanie podanej wartości w łańcuchu:
			- ```python
			  def search(head, searched_value):
				  current = head
				  while current:
					  if current.value == searched_value:
						  return True
					  current = current.next
				  return False
			  ```
- **Doubly Linked List**:
	- podobnie jak w Singly Linked List, z tą różnicą że jest tutaj **Head** oraz **Tail** i łańcuch może przechodzić w jedną stronę (od Head, jak w Singly Linked) oraz w drugą (od Tail do początu)
	- tutaj również zakończeniem Łańcucha jest zwrócenie None, z tą różnicą, że w obu kierunkach na końcu jest None
	- ```python
	  class Node:
		  def __init__(self, value, next=None, prev=None):
			self.value = value
			self.next = next
			self.prev = prev
		
		  def __str__(self):
			return str(self.value)
		  
	  class DoublyLinkedList:
		  def __init__(self, head=None, tail=None):
			self.head = head
			self.tail = tail
		
		  def append(self, value):
			new_node = Node(value)
			if not self.head:
			  self.head = self.tail = new_node
			else:
			  self.tail.next = new_node
			  new_node.prev = self.tail
			  self.tail = new_node
		
		  def prepend(self, value):
			new_node = Node(value)
			if not self.head:
			  self.head = self.tail = new_node
			else:
			  self.head.prev = new_node
			  new_node.next = self.head
			  self.head = new_node
		
		  def del_from_beginning(self):
			if not self.head:
			  print("List is empty")
			  return
			print(f"Deleting from beginning: {self.head.value}")
			if self.head == self.tail:
			  self.head = self.tail = None
			else:
			  self.head = self.head.next
			  self.head.prev = None
		
		  def del_from_ending(self):
			if not self.head:
			  print("List is empty")
			  return
			print(f"Deleting from ending: {self.tail.value}")
			if self.head == self.tail:
			  self.head = self.tail = None
			else:
			  self.tail = self.tail.prev
			  self.tail.next = None
		
		  def display_forward(self):
			current = self.head
			elements = []
			while current:
			  elements.append(str(current.value))
			  current = current.next
			print(f"Forwards: {' <-> '.join(elements)}")
		
		  def display_backward(self):
			current = self.tail
			elements = []
			while current:
			  elements.append(str(current.value))
			  current = current.prev
			print(f"Backwards: {' <-> '.join(elements)}")
		
		dll = DoublyLinkedList()
		dll.append(1)
		dll.append(2)
		dll.prepend(3)
		dll.append(9)
		dll.append(11)
		dll.prepend(5)
		
		dll.display_forward()
		dll.del_from_beginning()
		dll.display_forward()
		dll.del_from_ending()
		dll.display_forward()
	  ```

### Czym są hash tables (functions, sets & maps)?
#hash
- **Hashable data structures** – to  typy danych, które **mogą być użyte jako klucze w hash mapach (np. w dict)**, czyli takie, które mają stałą wartość hasha (są niemutowalne).
    - **hashowalne (immutable)**: `tuple`, `str`, `int`, `float`, `frozenset`
    - **niehashowalne (mutable)**: `dict`, `list`, `set`  
        (bo mogą się zmieniać, więc ich hash nie byłby stały)
- **Hash Function** – przekształca dane wejściowe (np. string, int, tuple) w liczbę całkowitą, czyli **hash value**.
    - Mamy np. **5 „bucketów”**, czyli pojemników (miejsc) na dane.
    - Funkcja hashująca może np.:
        - zamienić litery na liczby (a=1, b=2, c=3, itd.)
        - zsumować je - np. abc = 6
        - podzielić przez liczbę bucketów - 6 % 5 = 1
        - czyli wynik **1 to index bucketu**, do którego dane trafią
    - Dzięki temu możemy **od razu trafić do konkretnego miejsca w pamięci** – dlatego wyszukiwanie / dodawanie danych w hash mapie to średnio **O(1)**.
- **Kolizja** – występuje, gdy różne dane dają ten sam hash value i chcą trafić do tego samego bucketu.
    - Przykładowe rozwiązania:
        - **chaining** – w buckecie tworzy się lista (np. linked list) i kolejne elementy są po prostu dopisywane,
        - **open addressing** – szuka się kolejnego pustego bucketu.
    - Wtedy takie operacje mogą być **O(n)**, ale średnio i tak są **amortized O(1)**.
- **Hash Table** – to po prostu cała ta „tablica bucketów” w pamięci, w której dane są rozmieszczone według hash value.
- **Hash Map** – struktura danych oparta na hash table, która przechowuje **pary klucz–wartość** (np. dict).
    - **Wszystkie klucze są przepuszczane przez funkcję hashującą, co pozwala błyskawicznie znaleźć dane po kluczu.**
    - Dlatego operacje dodawania, usuwania i wyszukiwania są **O(1)** w czasie średnim.
- **Set** – działa bardzo podobnie do dict, tylko przechowuje **same klucze (bez wartości)**.
	- Wszystkie elementy w set są unikalne, bo każda wartość jest hashowana – więc nie może się powtórzyć.
	- Dzięki temu operacje typu in / add / remove też są \***O(1) amortized**.

[Data Structures & Algorithms](https://www.youtube.com/watch?v=TQMvBTKn2p0&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=3)