#data_structures #algorithms

## Czym są built in i user defined data structures?
#built_in #user_defined
- Przykłady **built in**:
	- list
	- tuple
	- set
	- dictionary
- Przykłady **user defined**:
	- stack
	- queue
	- linked list
	- tree
	- graph

## Czym różni się static array od dynamic array od strings?
#static_array #dynamic_array #strings
- W Python standardowo nie ma czegoś takiego jak static array z poziomu pisania kodu
- **Static array** - tablica, która nie zmienia swojej długości
	- mam 5 elementów, usuwam jeden to zostaje mi ta sama długość, tylko jedno miejsce mam niezagospodarowane
	- mam 5 elementów i dodać kolejny element to tworzy problem, bo mam stałą długość tablicy
- **Dynamic array** - w Python jest to list, która dynamicznie dostosowuje długość tablicy (listy)
- **Strings** - w Python strings są **niemutowalne**. Można dobrać się do zawartości po indexach, ale nie da się dodać / usunąć / zamienić znaku na początku / końcu / środku

## Jak działa stack?
#stack 
- **Stack** - stos; porównać można do ułożonych na półce talerzy:
	- jeśli mam 5 ponumerowanych talerzy, ułożonych jeden na drugim, to naturalną kolejnością wyciągania talerzy będzie nr. 5 > nr. 4 > nr. 3 > ... > nr. 1
		- czyli nie mogę dobrać się do talerza nr. 3, bez wcześniejszego dostępu do talerza nr. 4 i nr. 5 

## Jak użyć stack?
#stack 
- **Stack** to **user defined** data structure.
	- Można stacka używać jako list:
		- użycie na list **.append(*jakaś wartość*)**, doda po kolei wartości
		- kolejno użycie **.pop()** (bez podanego argumentu) usunie wartość z .pop zgodnie z zamysłem stack (czyli chronologicznie - od najświeższej do najstarszej)
		- ***list*\[-1]** również zwraca najświeższy element dodany do list

## Czym jest linked list?
#linked_list
- **Linked list** - struktura powiązanych list
	- listy są **węzłami (node)**, są połączone w łańcuchem i każda lista wskazuje na kolejną listę
- **Singly Linked List**:
	- każdy węzeł wskazuje na kolejny węzeł i łańcuch się zakańcza w momencie gdy ostatni węzeł nie ma kolejnej listy do powiązania, więc jego next będzie None
	- początkowy węzeł to **Head**, a zakończenie to po prostu zwrócenie None
	- ```python
	  class SinglyNode:
		  def __init__(self, value, next_node=None):
			  self.value = value
			  self.next_node = next_node
			  
		  def __str__(self):
			  return str(self.value)
			  
		Head = SinglyNode(1)
		A = SinglyNode(4)
		B = SinglyNode(7)
		C = SinglyNode(11)
		# powyższe to powiązania list w LinkedList
	  ```
		- wyświetlenie węzłów:
			- ```python
			  def display(head):
				  current = head
				  while current:
				  # zakończone w momencie gdy węzeł ksaże None, czyli koniec łańcucha
					  print(current)
					  current = current.next
					  # "przełączenie" na kolejny element łańcucha
			  ```
		- wyszukanie podanej wartości w łańcuchu:
			- ```python
			  def search(head, searched_value):
				  current = head
				  while current:
					  if current.value == searched_value:
						  return True
					  current = current.next
				  return False
			  ```
- **Doubly Linked List**:
	- podobnie jak w Singly Linked List, z tą różnicą że jest tutaj **Head** oraz **Tail** i łańcuch może przechodzić w jedną stronę (od Head, jak w Singly Linked) oraz w drugą (od Tail do początu)
	- tutaj również zakończeniem Łańcucha jest zwrócenie None, z tą różnicą, że w obu kierunkach na końcu jest None
	- ```python
	  class Node:
		  def __init__(self, value, next=None, prev=None):
			self.value = value
			self.next = next
			self.prev = prev
		
		  def __str__(self):
			return str(self.value)
		  
	  class DoublyLinkedList:
		  def __init__(self, head=None, tail=None):
			self.head = head
			self.tail = tail
		
		  def append(self, value):
			new_node = Node(value)
			if not self.head:
			  self.head = self.tail = new_node
			else:
			  self.tail.next = new_node
			  new_node.prev = self.tail
			  self.tail = new_node
		
		  def prepend(self, value):
			new_node = Node(value)
			if not self.head:
			  self.head = self.tail = new_node
			else:
			  self.head.prev = new_node
			  new_node.next = self.head
			  self.head = new_node
		
		  def del_from_beginning(self):
			if not self.head:
			  print("List is empty")
			  return
			print(f"Deleting from beginning: {self.head.value}")
			if self.head == self.tail:
			  self.head = self.tail = None
			else:
			  self.head = self.head.next
			  self.head.prev = None
		
		  def del_from_ending(self):
			if not self.head:
			  print("List is empty")
			  return
			print(f"Deleting from ending: {self.tail.value}")
			if self.head == self.tail:
			  self.head = self.tail = None
			else:
			  self.tail = self.tail.prev
			  self.tail.next = None
		
		  def display_forward(self):
			current = self.head
			elements = []
			while current:
			  elements.append(str(current.value))
			  current = current.next
			print(f"Forwards: {' <-> '.join(elements)}")
		
		  def display_backward(self):
			current = self.tail
			elements = []
			while current:
			  elements.append(str(current.value))
			  current = current.prev
			print(f"Backwards: {' <-> '.join(elements)}")
		
		dll = DoublyLinkedList()
		dll.append(1)
		dll.append(2)
		dll.prepend(3)
		dll.append(9)
		dll.append(11)
		dll.prepend(5)
		
		dll.display_forward()
		dll.del_from_beginning()
		dll.display_forward()
		dll.del_from_ending()
		dll.display_forward()
	  ```

[Data Structures & Algorithms](https://www.youtube.com/watch?v=TQMvBTKn2p0&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=3)