#big_O #time_complexity #space_complexity

## Na czym polega Big O notation?
#big_O 
- **Big O** - obrazuje złożoność algorytmiczną
	- czyli ile operacji (**time**) lub ile miejsca w pamięci RAM (**space**) potrzebuje program do wykonania, w zależności od rozmiaru danych wejściowych
	- Big O reprezentuje **zbliżony worst case scenario** (niżej o tym)
- przykład:
	- ```python
	  users = ["Kuba", "Ania", "Adrian", "Piotr", "Rafał"]
	  "Adrian" in users
	  ```
	- tutaj Python musi przejść po kolei po wszystkich elementach aż znajdzie dopasowanie, czyli **w najgorszym wypadku** musi wykonać 5 powtórzeń
		- to właśnie ten **worst case scenario**
	- jeśli danych wejściowych byłoby 5000 to program zajmie 5000 operacji
		- czyli jest to **złożoność O(n)**, czyli funkcja liniowa (im więcej danych wejściowych tym proporcjonalnie więcej operacji/czasu)

## Na czym polega Time Complexity?
#time_complexity 
- **Time Complexity** - jak długo działa / ile operacji wykonuje program w zależności od liczby danych wejściowych
	- wyraża się w **Big O notation**
- przykład:
	- ```python
	  for i in range(0, 2):
		  print(i)
	  ```
	- podany zakres ma 1 element, więc pętla wykona 1 iterację
		- dla zakresu 100 wykona się 100 iteracji
	- czyli jest to **O(n)**

## Na czym polega Space Complexity?
#space_complexity 
- **Space Complexity** - ile pamięci RAM potrzebuje program.
	- wyraża się w **Big O notation**
- przykład:
	- ```python
	  def double_list(nums):
		  return [x*2 for x in nums]
	  ```
		- tworzy nową listę takiej samej długości
			- jest to **O(n)**
	- ```python
	  def double_in_place(nums):
		  for i in range(len(nums)):
			  nums[i] *= 2
	  ```
		- podmienia dane istniejącej listy, więc zajmuje tyle samo miejsca
			- jest to **O(1)**, czyli stała