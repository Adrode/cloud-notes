#strings
## Jak tworzyć stringi?
#strings 
- **apostrofy i cudzysłowy** - nie ma różnicy, czy użyje się "*string*" czy '*string*', najważniejsze jest trzymanie się jednej konwencji dla spójności kodu
	- powszechna konwencja: **apostrofy dla id**, **cudzysłowy dla dłuższych tekstów**
- jeśli wewnątrz stringa ma być apostrof to:
	- **znak escape \\** przed wewnętrznym appostrofem
	- cały string w cudzysłowie, a apostrof wewnątrz będzie traktowany jako string
		- można też na odwrót, czyli na zewnątrz apostrofy a wewnątrz cudzysłów
- **"""*długi tekst na kilka linii*"""** - żeby rozbić tekst na kilka linii, to należy umieścić po 3 cudzysłowy otwierające i zamykające
	- można też dać potrójne apostrofy

## Czym jest i jak działa interpolacja stringa?
#string_interpolation
- **Interpolacja stringa** - mechanizm, który pozwala na umieszczanie wartości zmiennych bezpośrednio do łańcucha znaków (stringa).
- W Python jest to **f-string**:
	- ***nazwa_zmiennej* = f"Jakiś tekst {*nazwa_zmiennej_2*}"**
		- do nawiasu klamrowego można też dodawać wyrażenia (np. 2 + 2, zmienna ** 2, itd.)

## Jakie są metody dla stringów?
#string_methods #upper #lower #capitalize #strip #replace #split #slice
- np. **print(*zmienna*.metoda())** - syntax
	- **.upper()** - wszystkie litery wielkie
	- **.capitalize()** - pierwsza litera stringa będzie wielka
	- **.lower()** - wszystkie litery będą małe
	- **.startswith("a")** - jeśli string zaczyna się od podanego znaku to będzie zwrócone True
	- **.endswith("a")** - analogicznie jak wyżej, tylko ostatni znak łańcucha
	- **.strip()** - usunięcie białych znaków z początku i końca stringa; jak .trim() w JS
	- **.replace("*szukany_fragment_stringa*", "*nowy_string*", *opcjonalnie_liczba_wyszukań_podanego_fragmentu*)** - wyszukanie podanego łańcucha znaków w stringu i podmiana na nowy; można dodatkowo podać w argumencie liczbę podmian, jeśli szukanych łańcuchów jest w stringu więcej niż 1
	- **.split(" ")** - rozdziela string przez podany w argumencie **separator** i zwraca podzielony string jako kolejne elementy tablicy
	- **.casefold()** - wszystkie litery będą małe, niektóre znaki mogą zostać uproszczone (np. niemieckie ß == ss)
		- jest bardziej "agresywne", służy do porównywania ze sobą stringów
	- **.count("a")** - zwróci liczbę wszystkich, podanych w argumencie, znaków w stringu
		- może być też ciąg znaków lub zmienna
	- **.find("a")** - poda index, na którym znajduje się pierwszy znaleziony znak; jeśli nie zostanie znaleziony szukany łańcuch znaków, to zwróci -1, czyli nie będzie to traktowane jako błąd
	- **.index("a")** - poda index, na którym znajduje się pierwszy znaleziony znak; jeśli nie zostanie znaleziony szukany łańcuch znaków, to zwróci ValueError, czyli gdy chcemy żeby brak dopasowania spowodował błąd
		- dla obu powyższych: jeśli szukamy łańcucha znaków, to zostanie zwrócony index przeszukiwanego stringa, który wskazuje na początek szukanego łańcucha znaków

	- **string slicing:**
		- **zmienna\[id]** - zwróci znak pod zadanym indexem
		- **zmienna\[0:3]** - wyciągnie ze stringa znaki od indexów 0 (**włącznie**) do 3 (**wyłącznie**)
			- **\[0:-1]** - od początku do ostatniego indexu (**włącznie**)
			- **\[-1:]** - zwróci ostatni znak
			- **\[-3:]** - zwróci ostatnie 3 znaki
			- **\[-3:-1]** - ostatnie 3 znaki, ale bez ostatniego znaku