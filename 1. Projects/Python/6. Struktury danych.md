#list #set #dict #tuple
## Czym się różni lista od tablicy?
#list #array
- **Lista (list)** - przechowuje dane różnego typu
	- jest bardziej jest półka na którą można położyć dowolne rzeczy
- **Tablica (array z modułu array)** - przechowuje dane jednego typu
	- jest bardziej jak szuflada, do której można włożyć tylko konkretne przedmioty tego samego rodzaju 
	- jest trochę szybsza i bardziej oszczędna, ale jest rzadko wykorzystywana
- **Tablica NumPy (numpy.array)** - bardzo wydajna tablica, przechowuje liczby, idealna do data science, AI i matematyce (np. mnożenie wektorów, macierze - zaawansowane rzeczy)
## Jak utworzyć listę?
#list
- ***nazwa_zmiennej* = \[]**
	- pusta lista / tablica
- ***nazwa_zmiennej* = \["jakies_dane", "inne_dane"]**

## Jakie są metody dla list?
#list_methods
- **.append("*dane*")** - dodaje element na końcu listy
	- pozwala na dodanie tylko jednego elementu; jeśli spróbujemy więcej, to będzie to już obiekt, a na dodanie obiektu append nie pozwoli
- **.extend(\["*dane1*", "*dane2*"])** - rozszerza tablicę o elementy kolejnej tablicy; w argumencie musi być podana tablica, a nie pojedyncze elementy które chcemy dodać
- **.remove("*dane*")** - pierwszy znaleziony element zgodny z podanymi danymi zostanie usunięty
	- **del *nazwa_tablicy*\[id]** - usunie element o podanym indexie
- **.count("*dane*")** - wyliczy ile jest elementów w liście zgodnych z podanymi danymi
- **len(*nazwa_listy*)** - wyświetli długość listy
- **.sort()** - sortuje alfabetycznie lub rosnąco
	- nie działa, jeśli w tablicy są inty i stringi
	- dla stringów: wielkie litery > małe litery, więc wielkie będą w pierwszej kolejności
- **.sort(reverse=True)** - sortowanie w odwrotnej kolejności

## Jak używać set?
#set 
- **set** to inaczej **zbiór**
- ***nazwa_zmiennej* = {"dane1", "dane2", "dane3"}**
	- nie mają uporządkowanej wartości; brak indexu jak w list
	- mają unikalne wartości
		- jeśli w set mamy wpisane 2 takie same wartości, to zostanie wyświetlona tylko jedna wartość
- ***nazwa_zmiennej*.add("dane")** - dodanie wartości do setu
- ***nazwa_zmiennej*.update({"dane4", "dane5"})** - dodanie większej liczby elementów
	- do update() można przekazać {set} lub \[list] i będzie taki sam efekt
	- UWAGA! jeśli do update zostaną przekazane dane bez {} lub \[], np. update("dane4", "dane5"), to te słowa zostaną rozbite na znaki, więc finalnie do set zostaną dodane pojedynczo znaki
- ***nazwa_zmiennej*.remove("dane")** - usuwana przekazaną wartości z setu
- **na set można używać pętli for**

## Jak stworzyć pusty set?
#set 
- ***nazwa_zmiennej* = set()** - jak sprawdzimy type() to pokaże 'set'
	- ***nazwa_zmiennej* = {}** - nie utworzy pustego setu, tylko pusty **dict**

## Jakie są operacje na setach?
#set_operations
- ***set1* | *set2*** - **union**; doda do siebie oba zbiory i zwróci jeden zbiór ze wszystkimi elementami ze zbioru set1 i set2; pominie, jeśli coś się powtarza.
	- ew. ***set1*.union(*set2*)** - dziala tak samo
- ***set1* & *set2*** - **intersection**; zwróci tylko wspólne elementu z obu zbiorów
	- ew. ***set1*.intersection(*set2*)**
- ***set1* - *set2*** - **difference**; od pierwszego zbioru odejmie wspólne elementy pojawiające się w drugim zbiorze
	- ew. ***set1*.difference(*set2*)**
- ***set1* ^ *set2*** - **symmetric difference**; odwrotność intersection, czyli zwróci wszystkie elementy z obu zbiorów, poza tymi które należą do części wspólnej
	- ew. ***set1*.symmetric_difference(*set2*)**

## Jak używać dict?
#dict
- **dict** jest jak **obiekt w JS**; ma pary **klucz wartość**
	- nie posiada indexów, operuje się na kluczach
	- klucze są unikalne; każda kolejna próba przypisania takiego samego klucza do istniejącego dict spowoduje nadpisanie wartości tego klucza
		- czyli wpisanie 2 razy tego samego klucza w ciele dict nie wyrzuci błędu, tylko nadpisze wartość
- ***nazwa_zmiennej* = {
	- "Adrian": 25, # klucz: wartość
	- "Inna": 25,
- }**
- ***dict*.get("Klucz")** - zwróci wartość podanego klucza
	- zwróci None, jeśli podany klucz nie istnieje
- ***dict*\["Klucz"]** - zwróci wartość podanego klucza
	- zwróci błąd, jeśli podany klucz nie istnieje
- ***dict*.pop("Klucz")** - usunie parę klucz wartość
- **sorted(*dict*)** - zwróci posortowany dict

## Jak na dict używać pętli for?
#for #dict
- **for element in *set1*:**
	- wyświetli nazwy kluczy
- **for element in *set1*.values():**
	- wyświetli wszystkie wartości
- **for element in *set1*.items():**
	- wyświetli wszystkie pary (w formie **krotek** - o nich później)
- **for element in *set1*.items():**
	- print(f"{element\[0]}: {element\[1]}")
		- wtedy dobieramy się do klucza lub do wartości tak, jakbyśmy wskazywali z której kolumny mają wyjść dane
- **for name, number in *set1*.items():**
	- print(f"{name}: {number}")
		- działa jak wyżej, tylko bardziej czytelne
## Jak używać krotki (tuple)?
#tuple
- **Krotka to struktura niemutowalna!** Nie da się modyfikować jej zawartości
- ***nazwa_zmiennej* = ("dane1", "dane2", "dane3")**
	- ***tuple1*\[0]** - wyświetli element o wskazanym indexie
- **for name in *tuple1*:**
	- print(name)
		- wyświetli tak samo, jak set czy list
- Brak metod do usuwania czy dodawania danych